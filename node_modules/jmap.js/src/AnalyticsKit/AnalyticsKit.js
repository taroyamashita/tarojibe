(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.AnalyticsKit = mod.exports;
  }
})(this, function (module) {
  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _instance = null;

  var _jmap = {};

  var JMapAnalyticsKit = function () {

    /**
     * Init AnalyticsKit
     * @method constructor
     * @description Init method
     * @return {Object} AnalyticsKit
     */
    function JMapAnalyticsKit() {
      _classCallCheck(this, JMapAnalyticsKit);

      _jmap = global.jmap;
      this._eventTimes = [];
      this._loggingOptions = [];
      this._mapData = {};
      this._getLogCallback = null;
      this._setNotifiers();
    }

    /**
     * Shared Instance
     * @method sharedInstance
     * @description Shared Instance singlton
     * @return {Object} AnalyticsKit
     */


    _createClass(JMapAnalyticsKit, [{
      key: 'sharedInstance',
      value: function sharedInstance() {
        if (!_instance) {
          _instance = this;
        }
        return _instance;
      }
    }, {
      key: 'setloggingOptions',
      value: function setloggingOptions() {
        var loggingOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        this._loggingOptions = Array.isArray(loggingOptions) ? loggingOptions : [];
      }
    }, {
      key: 'analyticsKitDidGetLog',
      value: function analyticsKitDidGetLog(callback) {
        this._getLogCallback = typeof callback === 'function' ? callback : null;
      }
    }, {
      key: '_setNotifiers',
      value: function _setNotifiers() {
        var _this = this;

        var subscribers = [{
          name: 'JMAP_VIEW_TAP_SHAPE',
          option: 'shape',
          method: '_recordTapOnShapeWithData',
          returnString: ''
        }, {
          name: 'JMAP_VIEW_TAP_ICON',
          option: 'icon',
          method: '_recordTapOnIconWithData',
          returnString: ''
        }, {
          name: 'JMAP_VIEW_TAP',
          option: 'tap',
          method: '_recordTapOnXYWithData',
          returnString: ''
        }, {
          name: 'JMAP_CONTROLLER_MAP_SHOW',
          option: 'map',
          method: '_recordLoadedMapCountWithData',
          returnString: ''
        }, {
          name: 'JMAP_CORE_SERVER_REQUEST_START',
          option: 'server',
          method: '_startLoadFromServerEvent',
          returnString: ''
        }, {
          name: 'JMAP_CORE_SERVER_REQUEST_FAILED',
          option: 'server',
          method: '_endLoadFromServerEvent',
          returnString: 'JMAP_CORE_SERVER_REQUEST_FAILED'
        }, {
          name: 'JMAP_CORE_SERVER_REQUEST_SUCCESS',
          option: 'server',
          method: '_endLoadFromServerEvent',
          returnString: 'JMAP_CORE_SERVER_REQUEST_SUCCESS'
        }, {
          name: 'JMAP_ENGINE_PARSING_START',
          option: 'map',
          method: '_startEventWithTimerKey',
          returnString: 'JMapRendering-mapParsing'
        }, {
          name: 'JMAP_ENGINE_PARSING_FAILED',
          option: 'map',
          method: '_endRecordMapParsingWithKey',
          returnString: 'JMAP_ENGINE_PARSING_FAILED'
        }, {
          name: 'JMAP_ENGINE_PARSING_SUCCESS',
          option: 'map',
          method: '_endRecordMapParsingWithKey',
          returnString: 'JMAP_ENGINE_PARSING_SUCCESS'
        }, {
          name: 'JMAP_CONTROLLER_GENERATE_WAYPATH',
          option: 'waypath',
          method: '_recordWayfindPathWithValues',
          returnString: 'JMAP_ENGINE_PARSING_SUCCESS'
        }];

        subscribers.forEach(function (s) {
          _jmap.dispatcher.subscribe(s.name, function (data) {
            if (_this._shouldLogOption(s.option)) {
              _this[s.method](data, s.returnString);
            }
          });
        });
      }
    }, {
      key: '_shouldLogOption',
      value: function _shouldLogOption(option) {
        return !!this._loggingOptions.find(function (a) {
          return a === option;
        }) || this._loggingOptions.length === 0;
      }
    }, {
      key: '_recordTapOnShapeWithData',
      value: function _recordTapOnShapeWithData(data) {
        // Reduce meta object
        data.meta = {
          destinationIds: (data.meta || {}).destinationIds || [],
          waypointIds: (data.meta || {}).waypointIds || []
        };

        if (this._getLogCallback) {
          data.action = 'tapped';
          data.category = 'shape';
          this._getLogCallback(data);
        }
      }
    }, {
      key: '_recordTapOnIconWithData',
      value: function _recordTapOnIconWithData(data) {
        var iconType = data.iconType;

        if (this._getLogCallback) {
          data.action = 'tapped';
          data.category = iconType;
          this._getLogCallback(data);
        }
      }
    }, {
      key: '_recordTapOnXYWithData',
      value: function _recordTapOnXYWithData(data) {
        if (this._getLogCallback) {
          data.action = 'tapped';
          data.category = 'map';
          this._getLogCallback(data);
        }
      }
    }, {
      key: '_recordLoadedMapCountWithData',
      value: function _recordLoadedMapCountWithData(data) {
        if (this._getLogCallback) {
          data.action = 'show';
          data.category = 'map';
          this._getLogCallback(data);
        }
      }
    }, {
      key: '_startLoadFromServerEvent',
      value: function _startLoadFromServerEvent(data) {
        var endpoint = data.endpoint;
        this._startEventWithTimerKey(null, endpoint);
      }
    }, {
      key: '_endLoadFromServerEvent',
      value: function _endLoadFromServerEvent(data) {
        var endpoint = data.endpoint;
        var error = data.error;

        var status = 'success';
        if (error) {
          status = 'failed';
          data.error = error;
        }

        var times = this._endEventWithTimerKey(endpoint);

        if (times) {
          data.duration = times;
        }

        if (this._getLogCallback) {
          data.status = status;
          data.action = status;
          data.category = 'download';
          this._getLogCallback(data);
        }
      }
    }, {
      key: '_endRecordMapParsingWithKey',
      value: function _endRecordMapParsingWithKey(data) {
        var mapId = data.mapId;
        var error = data.error;
        var status = 'success';
        if (error) {
          status = 'failed';
        }

        var time = this._endEventWithTimerKey('JMapRendering-mapParsing');

        if (this._getLogCallback) {
          data.status = status;
          data.action = 'parsing';
          data.category = 'map';
          data.duration = time;
          this._getLogCallback(data);
        }

        var mapData = this._mapData;
        if (!mapData) {
          mapData = {};
        }

        var parsing = mapData.parsing;
        if (!parsing) {
          parsing = {};
        }

        parsing[mapId] = data;
        mapData.parsing = parsing;
        return this._mapData = mapData;
      }
    }, {
      key: '_recordWayfindPathWithValues',
      value: function _recordWayfindPathWithValues(data) {
        if (this._getLogCallback) {
          data.action = 'generate';
          data.category = 'wayfind';
          this._getLogCallback(data);
        }
      }
    }, {
      key: '_startEventWithTimerKey',
      value: function _startEventWithTimerKey(data, key) {
        if (typeof key === 'string' && key !== '') {
          this._eventTimes[key] = new Date();
        }
      }
    }, {
      key: '_endEventWithTimerKey',
      value: function _endEventWithTimerKey(key) {
        if (typeof key === 'string' && key !== '') {
          var startTime = this._eventTimes[key];
          if (startTime) {
            var endTime = new Date();

            var duration = endTime.getTime() - startTime.getTime();

            var timeRecord = { startTime: startTime, endTime: endTime, duration: duration };

            delete this._eventTimes.key;

            return timeRecord;
          }
        }
        return null;
      }
    }], [{
      key: '_makeTimestampForData',
      value: function _makeTimestampForData(data) {
        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
          data.loggedAt = new Date();
        }
        return data;
      }
    }, {
      key: '_recordCount',
      value: function _recordCount(count, d) {
        var data = d || {};
        var dataCount = data.count;
        if (count) {
          dataCount += count;
        } else {
          dataCount += 1;
        }

        data.count = dataCount;

        var timeStampArray = data.timeLogged;

        if (!timeStampArray) {
          timeStampArray = [];
        }

        timeStampArray.push(new Date());

        data.timeLogged = timeStampArray;

        return data;
      }
    }]);

    return JMapAnalyticsKit;
  }();

  module.exports = JMapAnalyticsKit;
});
//# sourceMappingURL=AnalyticsKit.js.map