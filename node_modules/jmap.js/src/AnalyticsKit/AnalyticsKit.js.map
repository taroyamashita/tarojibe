{"version":3,"sources":["../src/AnalyticsKit.js"],"names":["_instance","_jmap","JMapAnalyticsKit","global","jmap","_eventTimes","_loggingOptions","_mapData","_getLogCallback","_setNotifiers","loggingOptions","Array","isArray","callback","subscribers","name","option","method","returnString","forEach","dispatcher","subscribe","s","_shouldLogOption","data","find","a","length","meta","destinationIds","waypointIds","action","category","iconType","endpoint","_startEventWithTimerKey","error","status","times","_endEventWithTimerKey","duration","mapId","time","mapData","parsing","key","Date","startTime","endTime","getTime","timeRecord","loggedAt","count","d","dataCount","timeStampArray","timeLogged","push","module","exports"],"mappings":"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","file":"AnalyticsKit.js","sourcesContent":["let _instance = null\n\nlet _jmap = {}\n\nclass JMapAnalyticsKit {\n\n  /**\n   * Init AnalyticsKit\n   * @method constructor\n   * @description Init method\n   * @return {Object} AnalyticsKit\n   */\n  constructor() {\n    _jmap = global.jmap\n    this._eventTimes = []\n    this._loggingOptions = []\n    this._mapData = {}\n    this._getLogCallback = null\n    this._setNotifiers()\n  }\n\n  /**\n   * Shared Instance\n   * @method sharedInstance\n   * @description Shared Instance singlton\n   * @return {Object} AnalyticsKit\n   */\n  sharedInstance() {\n    if (!_instance) {\n      _instance = this\n    }\n    return _instance\n  }\n\n  /**\n   * Set Logging Options\n   * @method setloggingOptions\n   * @description Optional API to set parameters to log in analytics.\n   * @param {Array} loggingOptions\n   */\n  setloggingOptions(loggingOptions = []) {\n    this._loggingOptions = Array.isArray(loggingOptions) ? loggingOptions : []\n  }\n\n  /**\n   * DELEGATE METHODS\n   */\n\n  /**\n   * Analytics Kit Did Get Log\n   * @method analyticsKitDidGetLog\n   * @description Used to receive any recorded data in real time.\n   * @param {function} callback a function that can accept JSON.\n   */\n  analyticsKitDidGetLog(callback) {\n    this._getLogCallback = typeof callback === 'function' ? callback : null\n  }\n\n  /**\n   * PRIVATE NOTIFIERS\n   */\n\n  /**\n   * Set Notifiers\n   * @method _setNotifiers\n   * @description method to registers all listeners to begin listening for notifiers\n   * within the SDK and route to the appropriate method.\n   *  This method should be called in the class init file.\n   */\n  _setNotifiers() {\n    const subscribers = [\n      {\n        name: 'JMAP_VIEW_TAP_SHAPE',\n        option: 'shape',\n        method: '_recordTapOnShapeWithData',\n        returnString: '',\n      },\n      {\n        name: 'JMAP_VIEW_TAP_ICON',\n        option: 'icon',\n        method: '_recordTapOnIconWithData',\n        returnString: '',\n      },\n      {\n        name: 'JMAP_VIEW_TAP',\n        option: 'tap',\n        method: '_recordTapOnXYWithData',\n        returnString: '',\n      },\n      {\n        name: 'JMAP_CONTROLLER_MAP_SHOW',\n        option: 'map',\n        method: '_recordLoadedMapCountWithData',\n        returnString: '',\n      },\n      {\n        name: 'JMAP_CORE_SERVER_REQUEST_START',\n        option: 'server',\n        method: '_startLoadFromServerEvent',\n        returnString: '',\n      },\n      {\n        name: 'JMAP_CORE_SERVER_REQUEST_FAILED',\n        option: 'server',\n        method: '_endLoadFromServerEvent',\n        returnString: 'JMAP_CORE_SERVER_REQUEST_FAILED',\n      },\n      {\n        name: 'JMAP_CORE_SERVER_REQUEST_SUCCESS',\n        option: 'server',\n        method: '_endLoadFromServerEvent',\n        returnString: 'JMAP_CORE_SERVER_REQUEST_SUCCESS',\n      },\n      {\n        name: 'JMAP_ENGINE_PARSING_START',\n        option: 'map',\n        method: '_startEventWithTimerKey',\n        returnString: 'JMapRendering-mapParsing',\n      },\n      {\n        name: 'JMAP_ENGINE_PARSING_FAILED',\n        option: 'map',\n        method: '_endRecordMapParsingWithKey',\n        returnString: 'JMAP_ENGINE_PARSING_FAILED',\n      },\n      {\n        name: 'JMAP_ENGINE_PARSING_SUCCESS',\n        option: 'map',\n        method: '_endRecordMapParsingWithKey',\n        returnString: 'JMAP_ENGINE_PARSING_SUCCESS',\n      },\n      {\n        name: 'JMAP_CONTROLLER_GENERATE_WAYPATH',\n        option: 'waypath',\n        method: '_recordWayfindPathWithValues',\n        returnString: 'JMAP_ENGINE_PARSING_SUCCESS',\n      },\n    ]\n\n    subscribers.forEach(s => {\n      _jmap.dispatcher.subscribe(s.name, data => {\n        if (this._shouldLogOption(s.option)) {\n          this[s.method](data, s.returnString)\n        }\n      })\n    })\n  }\n\n  /**\n   *  Should Log Option\n   *  @method _shouldLogOption\n   *  @description Used to check if log type sould be logged.\n   *  @param {String} option log option name\n   *  @return {Boolean}\n   */\n  _shouldLogOption(option) {\n    return !!this._loggingOptions.find(a => a === option) || this._loggingOptions.length === 0\n  }\n\n  /**\n   * PRIVATE EVENT METHODS\n   */\n\n  /**\n   * Record Tap On Shape With Data\n   * @method _recordTapOnShapeWithData\n   * @description helper method to parse and write to logs\n   * @param {object} data to parse\n   */\n  _recordTapOnShapeWithData(data) {\n    // Reduce meta object\n    data.meta = {\n      destinationIds: (data.meta || {}).destinationIds || [],\n      waypointIds: (data.meta || {}).waypointIds || [],\n    }\n\n    if (this._getLogCallback) {\n      data.action = 'tapped'\n      data.category = 'shape'\n      this._getLogCallback(data)\n    }\n  }\n\n  /**\n   * Record Tap On Icon With Data\n   * @method _recordTapOnIconWithData\n   * @description helper method to parse and write to logs\n   * @param {object} data to parse\n   */\n  _recordTapOnIconWithData(data) {\n    const iconType = data.iconType\n\n    if (this._getLogCallback) {\n      data.action = 'tapped'\n      data.category = iconType\n      this._getLogCallback(data)\n    }\n  }\n\n  /**\n   * Record Tap On XY With Data\n   * @method _recordTapOnXYWithData\n   * @description helper method to parse and write to logs\n   * @param {object} data to parse\n   */\n  _recordTapOnXYWithData(data) {\n    if (this._getLogCallback) {\n      data.action = 'tapped'\n      data.category = 'map'\n      this._getLogCallback(data)\n    }\n  }\n\n  /**\n   * Record Loaded Map Count With Data\n   * @method _recordLoadedMapCountWithData\n   * @description helper method to parse and write to logs\n   * @param {object} data to parse\n   */\n  _recordLoadedMapCountWithData(data) {\n    if (this._getLogCallback) {\n      data.action = 'show'\n      data.category = 'map'\n      this._getLogCallback(data)\n    }\n  }\n\n  /**\n   * Start Load From Server Event\n   * @method _startLoadFromServerEvent\n   * @description helper method to parse and write to logs\n   * @param {object} data to parse\n   */\n  _startLoadFromServerEvent(data) {\n    const endpoint = data.endpoint\n    this._startEventWithTimerKey(null, endpoint)\n  }\n\n  /**\n   * End Load From Server Event\n   * @method _endLoadFromServerEvent\n   * @description helper method to parse and write to logs\n   * @param {String} name identifier\n   * @param {object} data to parse\n   */\n  _endLoadFromServerEvent(data) {\n    const endpoint = data.endpoint\n    const error = data.error\n\n    let status = 'success'\n    if (error) {\n      status = 'failed'\n      data.error = error\n    }\n\n    const times = this._endEventWithTimerKey(endpoint)\n\n    if (times) {\n      data.duration = times\n    }\n\n    if (this._getLogCallback) {\n      data.status = status\n      data.action = status\n      data.category = 'download'\n      this._getLogCallback(data)\n    }\n  }\n\n  /**\n   * End Record Map Parsing With Key\n   * @method _endRecordMapParsingWithKey\n   * @description helper method to parse and write to logs\n   * @param {object} data to parse\n   */\n  _endRecordMapParsingWithKey(data) {\n    const mapId = data.mapId\n    const error = data.error\n    let status = 'success'\n    if (error) {\n      status = 'failed'\n    }\n\n    const time = this._endEventWithTimerKey('JMapRendering-mapParsing')\n\n    if (this._getLogCallback) {\n      data.status = status\n      data.action = 'parsing'\n      data.category = 'map'\n      data.duration = time\n      this._getLogCallback(data)\n    }\n\n    let mapData = this._mapData\n    if (!mapData) {\n      mapData = {}\n    }\n\n    let parsing = mapData.parsing\n    if (!parsing) {\n      parsing = {}\n    }\n\n    parsing[mapId] = data\n    mapData.parsing = parsing\n    return (this._mapData = mapData)\n  }\n\n  /**\n   * Record Wayfind Path With Values\n   * @method _recordWayfindPathWithValues\n   * @description helper method to parse and write to logs\n   * @param {object} data to parse\n   */\n  _recordWayfindPathWithValues(data) {\n    if (this._getLogCallback) {\n      data.action = 'generate'\n      data.category = 'wayfind'\n      this._getLogCallback(data)\n    }\n  }\n\n  /**\n   * TIME STAMP GENERATOR\n   */\n\n  /**\n   * Make Timestamp For Data\n   * @method _makeTimestampForData\n   * @param {Object} data to write\n   * @description creates timestamp in data object\n   * @return {object} data\n   */\n  static _makeTimestampForData(data) {\n    if (typeof data === 'object') {\n      data.loggedAt = new Date()\n    }\n    return data\n  }\n\n\n  /**\n   * EVENT RECORDER\n   */\n\n  /**\n   * Record Count\n   * @method _recordCount\n   * @param {Number} count\n   * @param {Object} data\n   * @description Helper method to record count and timestamp the event\n   * @return {Object} with count and timestamp\n   */\n  static _recordCount(count, d) {\n    const data = d || {}\n    let dataCount = data.count\n    if (count) {\n      dataCount += count\n    } else {\n      dataCount += 1\n    }\n\n    data.count = dataCount\n\n    let timeStampArray = data.timeLogged\n\n    if (!timeStampArray) {\n      timeStampArray = []\n    }\n\n    timeStampArray.push(new Date())\n\n    data.timeLogged = timeStampArray\n\n    return data\n  }\n\n  /**\n   * TIME EVENT TRACKING\n   */\n\n  /**\n   * Start Event With Timer Key\n   * @method _startEventWithTimerKey\n   * @description Create and save a time key\n   * @param {String} timerKey\n   */\n  _startEventWithTimerKey(data, key) {\n    if (typeof key === 'string' && key !== '') {\n      this._eventTimes[key] = new Date()\n    }\n  }\n\n  /**\n   * End Event With Timer Key\n   * @method _endEventWithTimerKey\n   * @description Log event with the timer key\n   * @param {String} timerKey\n   * @return {Object} with all timestamp details\n   */\n  _endEventWithTimerKey(key) {\n    if (typeof key === 'string' && key !== '') {\n      const startTime = this._eventTimes[key]\n      if (startTime) {\n        const endTime = new Date()\n\n        const duration = endTime.getTime() - startTime.getTime()\n\n        const timeRecord = { startTime, endTime, duration }\n\n        delete this._eventTimes.key\n\n        return timeRecord\n      }\n    }\n    return null\n  }\n}\n\nmodule.exports = JMapAnalyticsKit\n"]}