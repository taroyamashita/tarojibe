{"version":3,"sources":["../src/DeviceKit.js"],"names":["DeviceCollection","DeviceKit","core","control","global","jmap","JCore","Error","JController","_core","_control","_activeVenue","activeVenue","_componentMap","_renderedDevices","devices","device","scale","animation","useHeading","deviceWp","getWaypointFromDevice","setMapTransform","Transform","x","coordinates","y","currentMapView","rotation","heading","waypoint","accessLevel","wayfindToDevice","points","reverse","path","wayfindBetweenWaypoints","drawWayfindingPath","config","map","maps","getById","mapId","parseMap","opts","id","name","orientation","rotateWithMap","position","sprite","createMovingObject","Object","assign","callback","url","_getUrl","get","error","data","_responseData","items","createBatch","_deviceWayfind","_focusToDevice","waypoints","waypointId","component","addComponent","removeComponent","displayObject","updateMovingObject","visible","_createDeviceDisplayObject","pauseRendering","getAll","forEach","showDevice","renderCurrentMapView","hideDevice","onComplete","pulseVisible","ms","pulseDuration","setTimeout","module","exports"],"mappings":"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","file":"DeviceKit.js","sourcesContent":["const DeviceCollection = require('./DeviceCollection')\n/**\n* Kit for working with Jibestream Devices\n*/\nclass DeviceKit {\n  /**\n   * Create a DeviceKit.\n   * @param {JCore} core - instanciated JCore\n   * @param {JController} control - instanciated JController\n   */\n  constructor(core = {}, control = {}) {\n    if (core instanceof global.jmap.core.JCore === false) {\n      throw new Error('DeviceKit uses JCore as it\\'s first argument.')\n    }\n    if (control instanceof global.jmap.JController === false) {\n      throw new Error('DeviceKit uses JController as it\\'s second argument.')\n    }\n    this._core = core\n    this._control = control\n    this._activeVenue = control.activeVenue\n    this._componentMap = {}\n    this._renderedDevices = {}\n    this.devices = new DeviceCollection()\n  }\n\n  _focusToDevice(device, scale, animation = {}, useHeading) {\n    const deviceWp = this.getWaypointFromDevice(device)\n    this._control.setMapTransform(new jmap.Transform({\n      x: deviceWp.coordinates[0],\n      y: deviceWp.coordinates[1],\n      scale: scale || this._control.currentMapView.scale,\n      rotation: useHeading ? -device.heading : this._control.currentMapView.rotation,\n      animation,\n    }))\n    return this\n  }\n\n  _deviceWayfind(waypoint, device, accessLevel, wayfindToDevice) {\n    const deviceWp = this.getWaypointFromDevice(device)\n    const points = [waypoint, deviceWp]\n    if (!wayfindToDevice) points.reverse()\n    const path = this._control.wayfindBetweenWaypoints(...points, accessLevel)\n    this._control.drawWayfindingPath(path)\n    return path\n  }\n\n  _createDeviceDisplayObject(device, config) {\n    const waypoint = this.getWaypointFromDevice(device)\n    const map = this._activeVenue.maps.getById(waypoint.mapId)\n    this._control.parseMap(map) // Ensure map is parsed\n    const opts = {\n      id: device.id,\n      name: device.name,\n      orientation: device.heading,\n      rotateWithMap: true,\n      position: waypoint.coordinates,\n      map,\n    }\n    const sprite = this._control.createMovingObject(Object.assign(opts, config))\n    this._renderedDevices[device.id] = sprite\n  }\n\n  _getUrl() {\n    return `/venue/${this._activeVenue.id}/device/full`\n  }\n\n  /**\n   * Make request to JACS to populate the DeviceCollection of the ActiveVenue\n   * @param {Function} callback - callback fired when devices are ready,\n   * passes error, deviceCollection as arguments\n   * @return {DeviceKit} DeviceKit\n   */\n  getDevices(callback = () => {}) {\n    const url = this._getUrl()\n    this._core.get(url, (error, data) => {\n      this._responseData = data\n      const devices = data.devices && data.devices.items ? data.devices.items : []\n      this.devices.createBatch(devices)\n      callback(error, this.devices)\n    })\n  }\n\n  /**\n   * Draws a path to the selected device\n   * @param {jmap.core.Waypoint} callback - waypoint to wayfind from\n   * @param {Device} device - device model\n   * @param {accessLevel} number - level of accessibility of the path\n   * @return {Array} List of path points, seperted by floor\n   */\n  wayfindToDevice(waypoint, device, accessLevel) {\n    return this._deviceWayfind(waypoint, device, accessLevel, true)\n  }\n\n  /**\n   * Draws a path from the selected device\n   * @param {jmap.core.Waypoint} waypoint - waypoint to wayfind to\n   * @param {Device} device - device model\n   * @param {accessLevel} number - level of accessibility of the path\n   * @return {Array} List of path points, seperted by floor\n   */\n  wayfindFromDevice(waypoint, device, accessLevel) {\n    return this._deviceWayfind(waypoint, device, accessLevel, false)\n  }\n\n  /**\n   * Focuses the view center to the position of the device, changes the mapView if needed\n   * @param {jmap.core.Waypoint} callback - waypoint to wayfind to\n   * @param {Device} device - device model\n   * @param {jmap.Animation} animation - animation definition\n   * @return {DeviceKit} DeviceKit\n   */\n  focusToDevice(device, scale, animation) {\n    return this._focusToDevice(device, scale, animation, false)\n  }\n\n  /**\n   * Rotates the map to match the device heading\n   * @param {Device} device - device model\n   * @return {DeviceKit} DeviceKit\n   */\n  focusToDeviceWithHeading(device, scale, animation) {\n    return this._focusToDevice(device, scale, animation, true)\n  }\n\n  /**\n   * Returns the waypoint matching the device waypointId if the waypoint exists in a loaded map\n   * @param {Device} device - device model\n   * @return {jmap.core.Waypoint} waypoint\n   */\n  getWaypointFromDevice(device) {\n    const map = this._activeVenue.maps.getById(device.mapId)\n    return map ? map.waypoints.getById(device.waypointId) : null\n  }\n\n  /**\n   * Adds an html component ontop of your devoce, commonly used for 'You are here' indicators\n   * @param {Device} device - device model\n   * @param {DOMElement} component - any html element wrapped in a div\n   * @return {DeviceKit} DeviceKit\n   */\n  addComponentOverDevice(device, component) {\n    const waypoint = this.getWaypointFromDevice(device)\n    const map = this._activeVenue.maps.getById(waypoint.mapId)\n    this._componentMap[device.id] = { component, map }\n    this._control.addComponent(component, map, waypoint.coordinates)\n    return this\n  }\n\n  /**\n   * Removes any html component added ontop of your device.\n   * @param {Device} device - device model\n   * @return {DeviceKit} DeviceKit\n   */\n  removeComponentFromDevice(device) {\n    const data = this._componentMap[device.id]\n    if (data) this._control.removeComponent(data.component, data.map)\n    delete this._componentMap[device.id]\n    return this\n  }\n\n  /**\n   * Display the device on its respecive map\n   * @param {Device} device - device model\n   * @param {DeviceViewConfig} config - configuration used to generate the appearance of the device.\n   * only read the first time a device is shown\n   * @return {DeviceKit} DeviceKit\n   */\n  showDevice(device, config) {\n    const displayObject = this._renderedDevices[device.id]\n    if (displayObject) {\n      this._control.updateMovingObject(displayObject, config)\n      displayObject.visible = true\n    }\n    else this._createDeviceDisplayObject(device, config)\n    return this\n  }\n\n  /**\n   * Hide the divice\n   * @param {Device} device - device model\n   * @return {DeviceKit} DeviceKit\n   */\n  hideDevice(device) {\n    const displayObject = this._renderedDevices[device.id]\n    if (displayObject) displayObject.visible = false\n    return this\n  }\n\n  /**\n   * Display all the devices on thier respecive maps\n   * @param {DeviceViewConfig} config - configuration used to generate the appearance of the device.\n   * only read the first time a device is shown\n   * @return {DeviceKit} DeviceKit\n   */\n  showAllDevices(config) {\n    this._control.pauseRendering()\n    this.devices.getAll().forEach(device => this.showDevice(device, config))\n    this._control.renderCurrentMapView()\n    return this\n  }\n\n  /**\n   * Hides all divices\n   * @return {DeviceKit} DeviceKit\n   */\n  hideAllDevices() {\n    this.devices.getAll().forEach(device => this.hideDevice(device))\n    return this\n  }\n\n  /**\n   * Plays a pulse animation for the decive once, fires an onComplete callback when done\n   * @param {Device} device - device model\n   * @param {Function} onComplete - callback fired once animation is complete\n   * @return {DeviceKit} DeviceKit\n   */\n  pingDevice(device, onComplete = () => {}) {\n    // NOTE: Currently there isn't a good way to run the pulse animation once.\n    const displayObject = this._renderedDevices[device.id]\n    if (displayObject) {\n      // HACK: Apply pulse visibility to trigger animation?\n      displayObject.pulseVisible = true\n      // HACK: Wait until pulse duration is complete and fire onComplete handler\n      const ms = displayObject.pulseDuration * 1000\n      global.setTimeout(() => {\n        if (typeof onComplete === 'function') onComplete()\n        displayObject.pulseVisible = false // HACK: Turn off animation by hiding the pulse?\n      }, ms)\n    }\n    return this\n  }\n}\n\nmodule.exports = DeviceKit\n\n/**\n * The configuration object for the creation and update of an asset\n * @typedef {Object} DeviceViewConfig\n * @property {number} [width=20] - The width of the icon\n * @property {number} [height=20] - The height of the icon\n * @property {string} [url] - The URL of the image to be used as the asset's icon\n * @property {boolean} [scaleWithMap=true] - Whether the asset's icon should scale with the map\n * @property {string} [iconColor] - If no url is provided for the icon, the colour of the default\n * icon\n *\n * @property {number} [confidenceMax] - The maximum radius of the confidence circle (in pixels)\n * @property {number} [confidencePercent] - The confidence in the position of the item\n * (between 0 and 1). 0 will hide the confidence circle; 1 will display the full circle\n * @property {string} [confidenceColor] - The color of the confidence circle in hexadecimal format\n * @property {number} [confidenceAlpha] - The transparency of the confidence circle\n * (between 0 and 1)\n *\n * @property {string} [pulseColor] - The color of the pulse circle\n * @property {number} [pulseStartAlpha] - The starting opacity of the pulse circle (between 0 and 1)\n * @property {number} [pulseEndAlpha] - The ending opacity of the pulse circle (between 0 and 1)\n * @property {number} [pulseDuration] - The length of time of the pulse animation (in seconds)\n * @property {number} [pulseDelay] - The delay between pulse animation (in seconds)\n * @property {boolean} [pulseVisible] - Whether the pulse should be visible\n */\n"]}