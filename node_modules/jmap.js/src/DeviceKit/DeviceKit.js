(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module', './DeviceCollection'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, require('./DeviceCollection'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, global.DeviceCollection);
    global.DeviceKit = mod.exports;
  }
})(this, function (module, DeviceCollection) {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var DeviceKit = function () {
    /**
     * Create a DeviceKit.
     * @param {JCore} core - instanciated JCore
     * @param {JController} control - instanciated JController
     */
    function DeviceKit() {
      var core = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var control = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, DeviceKit);

      if (core instanceof global.jmap.core.JCore === false) {
        throw new Error('DeviceKit uses JCore as it\'s first argument.');
      }
      if (control instanceof global.jmap.JController === false) {
        throw new Error('DeviceKit uses JController as it\'s second argument.');
      }
      this._core = core;
      this._control = control;
      this._activeVenue = control.activeVenue;
      this._componentMap = {};
      this._renderedDevices = {};
      this.devices = new DeviceCollection();
    }

    _createClass(DeviceKit, [{
      key: '_focusToDevice',
      value: function _focusToDevice(device, scale) {
        var animation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var useHeading = arguments[3];

        var deviceWp = this.getWaypointFromDevice(device);
        this._control.setMapTransform(new jmap.Transform({
          x: deviceWp.coordinates[0],
          y: deviceWp.coordinates[1],
          scale: scale || this._control.currentMapView.scale,
          rotation: useHeading ? -device.heading : this._control.currentMapView.rotation,
          animation: animation
        }));
        return this;
      }
    }, {
      key: '_deviceWayfind',
      value: function _deviceWayfind(waypoint, device, accessLevel, wayfindToDevice) {
        var _control;

        var deviceWp = this.getWaypointFromDevice(device);
        var points = [waypoint, deviceWp];
        if (!wayfindToDevice) points.reverse();
        var path = (_control = this._control).wayfindBetweenWaypoints.apply(_control, points.concat([accessLevel]));
        this._control.drawWayfindingPath(path);
        return path;
      }
    }, {
      key: '_createDeviceDisplayObject',
      value: function _createDeviceDisplayObject(device, config) {
        var waypoint = this.getWaypointFromDevice(device);
        var map = this._activeVenue.maps.getById(waypoint.mapId);
        this._control.parseMap(map); // Ensure map is parsed
        var opts = {
          id: device.id,
          name: device.name,
          orientation: device.heading,
          rotateWithMap: true,
          position: waypoint.coordinates,
          map: map
        };
        var sprite = this._control.createMovingObject(Object.assign(opts, config));
        this._renderedDevices[device.id] = sprite;
      }
    }, {
      key: '_getUrl',
      value: function _getUrl() {
        return '/venue/' + this._activeVenue.id + '/device/full';
      }
    }, {
      key: 'getDevices',
      value: function getDevices() {
        var _this = this;

        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

        var url = this._getUrl();
        this._core.get(url, function (error, data) {
          _this._responseData = data;
          var devices = data.devices && data.devices.items ? data.devices.items : [];
          _this.devices.createBatch(devices);
          callback(error, _this.devices);
        });
      }
    }, {
      key: 'wayfindToDevice',
      value: function wayfindToDevice(waypoint, device, accessLevel) {
        return this._deviceWayfind(waypoint, device, accessLevel, true);
      }
    }, {
      key: 'wayfindFromDevice',
      value: function wayfindFromDevice(waypoint, device, accessLevel) {
        return this._deviceWayfind(waypoint, device, accessLevel, false);
      }
    }, {
      key: 'focusToDevice',
      value: function focusToDevice(device, scale, animation) {
        return this._focusToDevice(device, scale, animation, false);
      }
    }, {
      key: 'focusToDeviceWithHeading',
      value: function focusToDeviceWithHeading(device, scale, animation) {
        return this._focusToDevice(device, scale, animation, true);
      }
    }, {
      key: 'getWaypointFromDevice',
      value: function getWaypointFromDevice(device) {
        var map = this._activeVenue.maps.getById(device.mapId);
        return map ? map.waypoints.getById(device.waypointId) : null;
      }
    }, {
      key: 'addComponentOverDevice',
      value: function addComponentOverDevice(device, component) {
        var waypoint = this.getWaypointFromDevice(device);
        var map = this._activeVenue.maps.getById(waypoint.mapId);
        this._componentMap[device.id] = { component: component, map: map };
        this._control.addComponent(component, map, waypoint.coordinates);
        return this;
      }
    }, {
      key: 'removeComponentFromDevice',
      value: function removeComponentFromDevice(device) {
        var data = this._componentMap[device.id];
        if (data) this._control.removeComponent(data.component, data.map);
        delete this._componentMap[device.id];
        return this;
      }
    }, {
      key: 'showDevice',
      value: function showDevice(device, config) {
        var displayObject = this._renderedDevices[device.id];
        if (displayObject) {
          this._control.updateMovingObject(displayObject, config);
          displayObject.visible = true;
        } else this._createDeviceDisplayObject(device, config);
        return this;
      }
    }, {
      key: 'hideDevice',
      value: function hideDevice(device) {
        var displayObject = this._renderedDevices[device.id];
        if (displayObject) displayObject.visible = false;
        return this;
      }
    }, {
      key: 'showAllDevices',
      value: function showAllDevices(config) {
        var _this2 = this;

        this._control.pauseRendering();
        this.devices.getAll().forEach(function (device) {
          return _this2.showDevice(device, config);
        });
        this._control.renderCurrentMapView();
        return this;
      }
    }, {
      key: 'hideAllDevices',
      value: function hideAllDevices() {
        var _this3 = this;

        this.devices.getAll().forEach(function (device) {
          return _this3.hideDevice(device);
        });
        return this;
      }
    }, {
      key: 'pingDevice',
      value: function pingDevice(device) {
        var onComplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

        // NOTE: Currently there isn't a good way to run the pulse animation once.
        var displayObject = this._renderedDevices[device.id];
        if (displayObject) {
          // HACK: Apply pulse visibility to trigger animation?
          displayObject.pulseVisible = true;
          // HACK: Wait until pulse duration is complete and fire onComplete handler
          var ms = displayObject.pulseDuration * 1000;
          global.setTimeout(function () {
            if (typeof onComplete === 'function') onComplete();
            displayObject.pulseVisible = false; // HACK: Turn off animation by hiding the pulse?
          }, ms);
        }
        return this;
      }
    }]);

    return DeviceKit;
  }();

  module.exports = DeviceKit;

  /**
   * The configuration object for the creation and update of an asset
   * @typedef {Object} DeviceViewConfig
   * @property {number} [width=20] - The width of the icon
   * @property {number} [height=20] - The height of the icon
   * @property {string} [url] - The URL of the image to be used as the asset's icon
   * @property {boolean} [scaleWithMap=true] - Whether the asset's icon should scale with the map
   * @property {string} [iconColor] - If no url is provided for the icon, the colour of the default
   * icon
   *
   * @property {number} [confidenceMax] - The maximum radius of the confidence circle (in pixels)
   * @property {number} [confidencePercent] - The confidence in the position of the item
   * (between 0 and 1). 0 will hide the confidence circle; 1 will display the full circle
   * @property {string} [confidenceColor] - The color of the confidence circle in hexadecimal format
   * @property {number} [confidenceAlpha] - The transparency of the confidence circle
   * (between 0 and 1)
   *
   * @property {string} [pulseColor] - The color of the pulse circle
   * @property {number} [pulseStartAlpha] - The starting opacity of the pulse circle (between 0 and 1)
   * @property {number} [pulseEndAlpha] - The ending opacity of the pulse circle (between 0 and 1)
   * @property {number} [pulseDuration] - The length of time of the pulse animation (in seconds)
   * @property {number} [pulseDelay] - The delay between pulse animation (in seconds)
   * @property {boolean} [pulseVisible] - Whether the pulse should be visible
   */
});
//# sourceMappingURL=DeviceKit.js.map