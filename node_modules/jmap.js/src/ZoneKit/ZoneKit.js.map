{"version":3,"sources":["../src/ZoneKit.js"],"names":["ZoneCollection","ZoneKit","core","control","global","jmap","JCore","Error","JController","_core","_control","_activeVenue","activeVenue","zones","getBoundsOfZoneOnMap","id","jMapPoint","x","y","mapId","maps","getById","zone","map","isZone","constructor","Map","wps","getWaypointsInZone","reduce","points","wp","push","coordinates","mapView","stage","getMapViewById","parseMap","currentMapView","locations","getLocations","waypoints","location","concat","waypointIds","allDestinations","destinations","currentDestinations","getByWaypoint","newDestinations","acc","curr","indexOf","allAmenities","amenities","currentAmenities","newAmenities","_getPointsFromZoneAndMap","length","Bounds","jungle","util","getBoundingBoxFromPoints","polygonPoints","_createConvexHull","polygon","shape","Polygon","style","getPolygonOfZoneOnMap","baseTypeName","Style","hexStyle","hexidecimal","Object","keys","forEach","a","_getParsedMapView","layer","guaranteeMapLayer","addShape","pauseRender","renderCurrentMapView","cb","url","_getUrl","get","error","data","_responseData","items","createBatch","zonePoints","area","_getAreaOfPolygon","centroid","p1","i","p2","f","Math","abs","searchType","_isJMapPoint","mapWps","filter","coordinate","distance","Infinity","closest","distanceBetweenPoints","originWp","getClosestWaypointToCoordinate","getClosestWaypointInArrayToWaypoint","units","getUnitFromWaypoint","styleShapes","Array","isArray","sort","b","penultimate","array","last","fn","set","cross","point","pop","lower","upper","reverse","origin","center","end","module","exports"],"mappings":"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","file":"ZoneKit.js","sourcesContent":["const ZoneCollection = require('./ZoneCollection')\n\n/**\n* Kit for working with Jibestream Zones\n*/\nclass ZoneKit {\n  /**\n   * Create a ZoneKit.\n   * @param {jmap.core} core - instantiated JCore\n   * @param {jmap.JController} control - instantiated JController\n   */\n  constructor(core = {}, control = {}) {\n    if (core instanceof global.jmap.core.JCore === false) {\n      throw new Error('ZoneKit uses JCore as its first argument.')\n    }\n    if (control instanceof global.jmap.JController === false) {\n      throw new Error('ZoneKit uses JController as its second argument.')\n    }\n    this._core = core\n    this._control = control\n    this._activeVenue = control.activeVenue\n    this.zones = new ZoneCollection()\n\n    this.getBoundsOfZoneOnMap = this.getBoundsOfZoneOnMap\n  }\n\n  /**\n   * @access private\n   * @desc - Returns the URL to use when fetching zones\n   * @return {String} - The URL used to fetch zones\n   */\n  _getUrl() {\n    return `/venue/${this._activeVenue.id}/zone/full`\n  }\n\n  /**\n   * @access private\n   * @desc - Returns a boolean for whether the specified object is a valid\n   * jMapPoint for the current active venue. This is, has a numeric x and y\n   * and a map ID that matches a map in the active venue\n   * @param {jMapPoint} jMapPoint - The object to test\n   * @return {Boolean} - Whether the specified object is a valid jMapPoint\n   */\n  _isJMapPoint(jMapPoint) {\n    return typeof jMapPoint.x === 'number' &&\n           typeof jMapPoint.y === 'number' &&\n           typeof jMapPoint.mapId === 'number' &&\n           this._activeVenue.maps.getById(jMapPoint.mapId)\n  }\n\n  /**\n   * @access private\n   * @desc - Returns an array of points/coordinates as [x, y], which represent\n   * the waypoints for a specified zone on a specified map\n   * @param {Zone} zone - The zone that the waypoints are associated with\n   * @param {jmap.core.Map} map - The map on which the waypoints lie\n   * @return {Array[]} - An array of points/coordinates as [x, y]\n   */\n  _getPointsFromZoneAndMap(zone, map) {\n    if (this.zones.isZone(zone) && map && map.constructor === jmap.core.Map) {\n      const wps = this.getWaypointsInZone(zone)\n      return wps.reduce((points, wp) => {\n        if (wp.mapId === map.id) points.push(wp.coordinates)\n        return points\n      }, [])\n    }\n    return []\n  }\n\n  /**\n   * @access private\n   * @desc - Returns a parsed map view from the controllers\n   * @param {jmap.core.Map} map - The map to parse\n   * @return {jungle.MapView} - Map view\n   */\n  _getParsedMapView(map) {\n    let mapView = this._control.stage.getMapViewById(map.id)\n    if (!mapView) {\n      this._control.parseMap(map)\n      mapView = this._control.stage.getMapViewById(map.id) || this._control.stage.currentMapView\n    }\n    return mapView\n  }\n\n  /**\n   * @access private\n   * @desc - Returns the area of a convex polygon, given as a set of points\n   * @param {jMapPoint} jMapPoint - The object to test\n   * @return {Boolean} - Whether the specified object is a valid jMapPoint\n   */\n  static _getAreaOfPolygon(polygon) {\n    if (polygon.baseTypeName === 'Polygon' && polygon.points) {\n      const area = polygon.points.reduce((acc, p1, i, points) => {\n        // If previous point is unavailable, use last point.\n        const p2 = points[i - 1 > -1 ? i - 1 : points.length - 1]\n        return (acc + (p1[0] * p2[1])) - (p1[1] * p2[0])\n      }, 0)\n\n      // if points are given in reverse order, you'll get an errant negative area\n      return Math.abs(area / 2)\n    }\n    return null\n  }\n\n  /**\n   * @access private\n   * @desc - Returns an array of points represting the convex hull of a given set of points.\n   * That is, the shape that emulates what would happen if you placed a rubber band\n   * around the points\n   * @param {Array[]} points - A collection of points/coordinates, given as [x, y]\n   * @return {Array[]} - An array of points/coordinates as [x, y] representing the convex hull\n   * Returns null if an invalid input is given\n   */\n  static _createConvexHull(points) {\n    if (Array.isArray(points)) {\n      // sort points in ascending order of x coordinate,\n      // then by ascending order of y coordinate if x coordinates are equal\n      points.sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]))\n\n      // gets second to last/last element in array\n      const penultimate = array => array[array.length - 2]\n      const last = array => array[array.length - 1]\n\n      const fn = set => {\n        const array = []\n        set.forEach(point => {\n          while (array.length >= 2 && ZoneKit.cross(penultimate(array), last(array), point) <= 0) {\n            array.pop()\n          }\n          array.push(point)\n        })\n        array.pop()\n        return array\n      }\n\n      // gets lower and upper bounds of convex hull\n      const lower = fn(points)\n      const upper = fn(points.reverse())\n\n      return lower.concat(upper)\n    }\n    return null\n  }\n\n  /**\n   * @access private\n   * @desc - Checks the line formed by origin, center and end and returns a negative number\n   * if the angle going clockwise from origin to end is more than 180 degrees\n   * @param {Array} origin - The origin point, given as [x, y]\n   * @param {Array} center - The center point, given as [x, y]\n   * @param {Array} end - The ending point, given as [x, y]\n   * @return {Number} - An integer representing whether the angle goes in a clockwise\n   * or counterclockwise manner\n   */\n  static cross(origin, center, end) {\n    const a = (origin[0] - end[0]) * (center[1] - end[1])\n    const b = (origin[1] - end[1]) * (center[0] - end[0])\n    return a - b\n  }\n\n  /**\n   * @access public\n   * @desc - Returns all waypoints associated with a given Zone (or returns an empty array)\n   * @param {Zone} zone - The Zone we're using to search for waypoints\n   * @return {jmap.core.Waypoint[]} - The waypoints associated with a given zone (or an empty array)\n   * @example\n   * const zone = zoneKit.zones.getAll()[0]\n   * const waypoints = zoneKit.getWaypointsInZone(zone)\n   */\n  getWaypointsInZone(zone) {\n    if (this.zones.isZone(zone)) {\n      const locations = zone.getLocations()\n      return locations.reduce((waypoints, location) => {\n        const map = this._activeVenue.maps.getById(location.mapId)\n        if (map) {\n          return waypoints.concat(...location.waypointIds.map(id => map.waypoints.getById(id)))\n        }\n        return waypoints\n      }, [])\n    }\n    return []\n  }\n\n  /**\n   * @access public\n   * @desc - Returns all destinations associated with waypoints within an zone\n   * (or returns an empty array)\n   * @param {Zone} zone - The Zone we're using to search for destinations\n   * @return {jmap.core.Destination[]} - The destinations associated with a given zone\n   * (or an empty array)\n   * @example\n   * const zone = zoneKit.zones.getAll()[0]\n   * const destinations = zoneKit.getDestinationInZone(zone)\n   */\n  getDestinationsInZone(zone) {\n    if (this.zones.isZone(zone)) {\n      const waypoints = this.getWaypointsInZone(zone)\n      const allDestinations = this._activeVenue.destinations\n\n      return waypoints.reduce((destinations, wp) => {\n        const currentDestinations = allDestinations.getByWaypoint(wp)\n        const newDestinations = currentDestinations.reduce((acc, curr) => {\n          if (destinations.indexOf(curr) === -1) acc.push(curr)\n          return acc\n        }, [])\n        return destinations.concat(newDestinations)\n      }, [])\n    }\n    return []\n  }\n\n  /**\n   * @access public\n   * @desc - Returns all amenity instances associated with waypoints within an zone\n   * (or returns an empty array)\n   * @param {Zone} zone - The Zone we're using to search for destinations\n   * @return {jmap.core.Amentity[]} - The amenities associated with a given zone (or an empty array)\n   * @example\n   * const zone = zoneKit.zones.getAll()[0]\n   * const amentities = zoneKit.getAmenitiesInZone(zone)\n   */\n  getAmenitiesInZone(zone) {\n    if (this.zones.isZone(zone)) {\n      const waypoints = this.getWaypointsInZone(zone)\n      const allAmenities = this._activeVenue.amenities\n\n      return waypoints.reduce((amenities, wp) => {\n        const currentAmenities = allAmenities.getByWaypoint(wp)\n        const newAmenities = currentAmenities.reduce((acc, curr) => {\n          if (amenities.indexOf(curr) === -1) acc.push(curr)\n          return acc\n        }, [])\n        return amenities.concat(newAmenities)\n      }, [])\n    }\n    return []\n  }\n\n  /**\n   * @access public\n   * @desc - For a given Zone, return the bounding box for the associated waypoints\n   * on the specified map\n   * If an invalid zone or map is given, null is returned\n   * @param {Zone} zone - The Zone we're using to calculate bounding boxes\n   * @param {jmap.core.Map} map - The map we'll use to calculate the bounding box\n   * @return {jmap.Bounds} - A Bounds object\n   * @example\n   * const zone = zoneKit.zones.getAll()[0]\n   * const map = control.currentMap\n   * const bounds = zoneKit.getBoundsOfZone(zone, map)\n   */\n  getBoundsOfZoneOnMap(zone, map) {\n    const points = this._getPointsFromZoneAndMap(zone, map)\n    if (points.length >= 2) { // at least two points needed to create a bounding box\n      return new jmap.Bounds(this._control.jungle.util.getBoundingBoxFromPoints(points))\n    }\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Returns a polygon shape, based on the waypoints associated with the specified zone\n   * on the specified map. The zone must have three or more waypoints associated with it on the\n   * given map, otherwise null will be returned\n   * @param {Zone} zone - The Zone we're using to calculate polygons\n   * @param {jmap.core.Map} map - The map we'll use to calculate the polygon\n   * @return {jmap.jungle.shape.Polygon} - A Polygon object\n   * @example\n   * const zone = zoneKit.zones.getAll()[0]\n   * const map = control.currentMap\n   * const polygon = zoneKit.getPolygonOfZone(zone, map)\n   */\n  getPolygonOfZoneOnMap(zone, map) {\n    const points = this._getPointsFromZoneAndMap(zone, map)\n    if (points.length >= 3) { // at least three points needed to create a polygon\n      const polygonPoints = ZoneKit._createConvexHull(points)\n      polygonPoints.push(polygonPoints[0])\n      const polygon = new this._control.jungle.shape.Polygon({ points: polygonPoints })\n      return polygon\n    }\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Given a specific Zone, draw a polygon the encompasses all of its waypoints\n   * on the specified map\n   * @param {Zone} zone - The Zone we wish to highlight using a polygon\n   * @param {jmap.core.Map} map - The map we wish to draw the polygon on\n   * @param {jmap.Style} style - The way in which the polygon should be styled\n   * @return {Polygon} - The polygon that was drawn\n   * @example\n   * const zone = zoneKit.zones.getAll()[0]\n   * const map = control.currentMap\n   * const polygon = zoneKit.drawPolygonOfZone(zone, map)\n   */\n  drawPolygonOfZoneOnMap(zone, map, style) {\n    const polygon = this.getPolygonOfZoneOnMap(zone, map)\n    if (polygon && polygon.baseTypeName === 'Polygon') {\n      if (style && style.constructor === jmap.Style) {\n        const hexStyle = style.hexidecimal()\n        Object.keys(hexStyle).forEach(a => {\n          if (typeof hexStyle[a] === 'number') polygon[a] = hexStyle[a]\n        })\n      }\n\n      const mapView = this._getParsedMapView(map)\n      const layer = mapView.guaranteeMapLayer('Zones')\n      layer.addShape(polygon)\n      if (!this._control.pauseRender) this._control.renderCurrentMapView()\n      return polygon\n    }\n\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Returns all zones for the currently loaded building\n   * @param {Function} [cb] - The callback function, which will run\n   * once the Zones have been retrieved. The Zones will be stored in this.zones\n   * @return {ZoneKit} - The current ZoneKit instance\n   * @example\n   * const fn = (error, zones) => console.log(zones)\n   * zoneKit.getZones(fn)\n   */\n  getZones(cb) {\n    const url = this._getUrl()\n    this._core.get(url, (error, data) => {\n      this._responseData = data\n      const zones = data.zones && data.zones.items ? data.zones.items : []\n      this.zones = new ZoneCollection()\n      this.zones.createBatch(zones)\n      cb(error, this.zones)\n    })\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Return the coordinates of the centroid of a given zone on the given map\n   * The zone must have three or more waypoints associated with it on the given map\n   * otherwise null will be returned\n   * @param {Zone} zone - The zone we wish to find the centroid of\n   * @param {jmap.core.Map} map - The map on which we'll use to find the centroid\n   * @return {Number[]} - The centroid in the form of [x, y]\n   * @example\n   * const zone = zoneKit.zones.getAll()[0]\n   * const map = control.currentMap\n   * const centroid = zoneKit.getCentroidOfZone(zone, map)\n   */\n  getCentroidOfZoneOnMap(zone, map) {\n    const zonePoints = this._getPointsFromZoneAndMap(zone, map)\n    if (zonePoints.length >= 3) {\n      const polygon = this.getPolygonOfZoneOnMap(zone, map)\n      if (polygon) {\n        const area = ZoneKit._getAreaOfPolygon(polygon) * 6\n        const centroid = polygon.points.reduce((acc, p1, i, points) => {\n          const p2 = points[i - 1 > -1 ? i - 1 : points.length - 1]\n          const f = (p1[0] * p2[1]) - (p2[0] * p1[1])\n          const x = (p1[0] + p2[0]) * f\n          const y = (p1[1] + p2[1]) * f\n          return [acc[0] + x, acc[1] + y]\n        }, [0, 0])\n\n        return centroid.map(a => Math.abs(a / area))\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Given a specific point on the a map,\n   * return the closest waypoint associated with the given Zone\n   * @param {Zone} zone - The zone we wish to search within\n   * @param {jMapPoint} jMapPoint - The point we wish to search with\n   * @param {String} [searchType='proximity'] - Either 'proximity' or 'grid'\n   * @return {jmap.core.Waypoint} - The closest waypoint within the specified Zone\n   * to the provided point\n   * @example\n   * const jMapPoint = { x: 2750, y: 2750, mapId: control.currentMap.id }\n   * const zone = zoneKit.zones.getAll()[0]\n   * const waypoint = zoneKit.getClosestWaypointInZoneToPoint(zone, jMapPoint)\n   */\n  getClosestWaypointInZoneToPoint(zone, jMapPoint, searchType = 'proximity') {\n    if (this._isJMapPoint(jMapPoint)) {\n      const wps = this.getWaypointsInZone(zone)\n      const mapWps = wps.filter(wp => wp.mapId === jMapPoint.mapId)\n      const coordinate = [jMapPoint.x, jMapPoint.y]\n      if (mapWps.length) {\n        if (searchType === 'proximity') {\n          let distance = Infinity\n          const closest = mapWps.reduce((acc, curr) => {\n            const distanceBetweenPoints = this._control.jungle.util.distanceBetweenPoints\n            if (distanceBetweenPoints(coordinate, curr) < distance) {\n              distance = distanceBetweenPoints(coordinate, curr)\n              return curr\n            }\n            return acc\n          })\n          return closest\n        } else if (searchType === 'grid') {\n          const originWp = this._activeVenue.getClosestWaypointToCoordinate(coordinate, mapWps)\n          return this._activeVenue.getClosestWaypointInArrayToWaypoint(originWp, wps)\n        }\n      }\n    }\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Highlight all units associated to a specific zone\n   * using either the color specified in the CMS or the color override provided\n   * @param {Zone} zone - The zone we wish to highlight\n   * @param {jmap.Style} style - The way in which the unit will be styled\n   * @return {ZoneKit} - The current ZoneKit instance\n   * @example\n   * const zone = zoneKit.zones.getAll()[0]\n   * const style = new jmap.Style({ fill: '#4a85e2' })\n   * zoneKit.highlightUnitsInZone(zone, style)\n   */\n  highlightUnitsInZone(zone, style) {\n    if (style && style.constructor === jmap.Style) {\n      const wps = this.getWaypointsInZone(zone)\n      const units = wps.map(wp => this._control.getUnitFromWaypoint(wp)).filter(a => a)\n      this._control.styleShapes(units, style)\n    }\n    return this\n  }\n}\n\nmodule.exports = ZoneKit\n"]}