(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module', './ZoneCollection'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, require('./ZoneCollection'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, global.ZoneCollection);
    global.ZoneKit = mod.exports;
  }
})(this, function (module, ZoneCollection) {
  'use strict';

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var ZoneKit = function () {
    /**
     * Create a ZoneKit.
     * @param {jmap.core} core - instantiated JCore
     * @param {jmap.JController} control - instantiated JController
     */
    function ZoneKit() {
      var core = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var control = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ZoneKit);

      if (core instanceof global.jmap.core.JCore === false) {
        throw new Error('ZoneKit uses JCore as its first argument.');
      }
      if (control instanceof global.jmap.JController === false) {
        throw new Error('ZoneKit uses JController as its second argument.');
      }
      this._core = core;
      this._control = control;
      this._activeVenue = control.activeVenue;
      this.zones = new ZoneCollection();

      this.getBoundsOfZoneOnMap = this.getBoundsOfZoneOnMap;
    }

    /**
     * @access private
     * @desc - Returns the URL to use when fetching zones
     * @return {String} - The URL used to fetch zones
     */


    _createClass(ZoneKit, [{
      key: '_getUrl',
      value: function _getUrl() {
        return '/venue/' + this._activeVenue.id + '/zone/full';
      }
    }, {
      key: '_isJMapPoint',
      value: function _isJMapPoint(jMapPoint) {
        return typeof jMapPoint.x === 'number' && typeof jMapPoint.y === 'number' && typeof jMapPoint.mapId === 'number' && this._activeVenue.maps.getById(jMapPoint.mapId);
      }
    }, {
      key: '_getPointsFromZoneAndMap',
      value: function _getPointsFromZoneAndMap(zone, map) {
        if (this.zones.isZone(zone) && map && map.constructor === jmap.core.Map) {
          var wps = this.getWaypointsInZone(zone);
          return wps.reduce(function (points, wp) {
            if (wp.mapId === map.id) points.push(wp.coordinates);
            return points;
          }, []);
        }
        return [];
      }
    }, {
      key: '_getParsedMapView',
      value: function _getParsedMapView(map) {
        var mapView = this._control.stage.getMapViewById(map.id);
        if (!mapView) {
          this._control.parseMap(map);
          mapView = this._control.stage.getMapViewById(map.id) || this._control.stage.currentMapView;
        }
        return mapView;
      }
    }, {
      key: 'getWaypointsInZone',
      value: function getWaypointsInZone(zone) {
        var _this = this;

        if (this.zones.isZone(zone)) {
          var locations = zone.getLocations();
          return locations.reduce(function (waypoints, location) {
            var map = _this._activeVenue.maps.getById(location.mapId);
            if (map) {
              return waypoints.concat.apply(waypoints, _toConsumableArray(location.waypointIds.map(function (id) {
                return map.waypoints.getById(id);
              })));
            }
            return waypoints;
          }, []);
        }
        return [];
      }
    }, {
      key: 'getDestinationsInZone',
      value: function getDestinationsInZone(zone) {
        if (this.zones.isZone(zone)) {
          var waypoints = this.getWaypointsInZone(zone);
          var allDestinations = this._activeVenue.destinations;

          return waypoints.reduce(function (destinations, wp) {
            var currentDestinations = allDestinations.getByWaypoint(wp);
            var newDestinations = currentDestinations.reduce(function (acc, curr) {
              if (destinations.indexOf(curr) === -1) acc.push(curr);
              return acc;
            }, []);
            return destinations.concat(newDestinations);
          }, []);
        }
        return [];
      }
    }, {
      key: 'getAmenitiesInZone',
      value: function getAmenitiesInZone(zone) {
        if (this.zones.isZone(zone)) {
          var waypoints = this.getWaypointsInZone(zone);
          var allAmenities = this._activeVenue.amenities;

          return waypoints.reduce(function (amenities, wp) {
            var currentAmenities = allAmenities.getByWaypoint(wp);
            var newAmenities = currentAmenities.reduce(function (acc, curr) {
              if (amenities.indexOf(curr) === -1) acc.push(curr);
              return acc;
            }, []);
            return amenities.concat(newAmenities);
          }, []);
        }
        return [];
      }
    }, {
      key: 'getBoundsOfZoneOnMap',
      value: function getBoundsOfZoneOnMap(zone, map) {
        var points = this._getPointsFromZoneAndMap(zone, map);
        if (points.length >= 2) {
          // at least two points needed to create a bounding box
          return new jmap.Bounds(this._control.jungle.util.getBoundingBoxFromPoints(points));
        }
        return null;
      }
    }, {
      key: 'getPolygonOfZoneOnMap',
      value: function getPolygonOfZoneOnMap(zone, map) {
        var points = this._getPointsFromZoneAndMap(zone, map);
        if (points.length >= 3) {
          // at least three points needed to create a polygon
          var polygonPoints = ZoneKit._createConvexHull(points);
          polygonPoints.push(polygonPoints[0]);
          var polygon = new this._control.jungle.shape.Polygon({ points: polygonPoints });
          return polygon;
        }
        return null;
      }
    }, {
      key: 'drawPolygonOfZoneOnMap',
      value: function drawPolygonOfZoneOnMap(zone, map, style) {
        var polygon = this.getPolygonOfZoneOnMap(zone, map);
        if (polygon && polygon.baseTypeName === 'Polygon') {
          if (style && style.constructor === jmap.Style) {
            var hexStyle = style.hexidecimal();
            Object.keys(hexStyle).forEach(function (a) {
              if (typeof hexStyle[a] === 'number') polygon[a] = hexStyle[a];
            });
          }

          var mapView = this._getParsedMapView(map);
          var layer = mapView.guaranteeMapLayer('Zones');
          layer.addShape(polygon);
          if (!this._control.pauseRender) this._control.renderCurrentMapView();
          return polygon;
        }

        return null;
      }
    }, {
      key: 'getZones',
      value: function getZones(cb) {
        var _this2 = this;

        var url = this._getUrl();
        this._core.get(url, function (error, data) {
          _this2._responseData = data;
          var zones = data.zones && data.zones.items ? data.zones.items : [];
          _this2.zones = new ZoneCollection();
          _this2.zones.createBatch(zones);
          cb(error, _this2.zones);
        });
        return this;
      }
    }, {
      key: 'getCentroidOfZoneOnMap',
      value: function getCentroidOfZoneOnMap(zone, map) {
        var zonePoints = this._getPointsFromZoneAndMap(zone, map);
        if (zonePoints.length >= 3) {
          var polygon = this.getPolygonOfZoneOnMap(zone, map);
          if (polygon) {
            var area = ZoneKit._getAreaOfPolygon(polygon) * 6;
            var centroid = polygon.points.reduce(function (acc, p1, i, points) {
              var p2 = points[i - 1 > -1 ? i - 1 : points.length - 1];
              var f = p1[0] * p2[1] - p2[0] * p1[1];
              var x = (p1[0] + p2[0]) * f;
              var y = (p1[1] + p2[1]) * f;
              return [acc[0] + x, acc[1] + y];
            }, [0, 0]);

            return centroid.map(function (a) {
              return Math.abs(a / area);
            });
          }
        }

        return null;
      }
    }, {
      key: 'getClosestWaypointInZoneToPoint',
      value: function getClosestWaypointInZoneToPoint(zone, jMapPoint) {
        var _this3 = this;

        var searchType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'proximity';

        if (this._isJMapPoint(jMapPoint)) {
          var wps = this.getWaypointsInZone(zone);
          var mapWps = wps.filter(function (wp) {
            return wp.mapId === jMapPoint.mapId;
          });
          var coordinate = [jMapPoint.x, jMapPoint.y];
          if (mapWps.length) {
            if (searchType === 'proximity') {
              var distance = Infinity;
              var closest = mapWps.reduce(function (acc, curr) {
                var distanceBetweenPoints = _this3._control.jungle.util.distanceBetweenPoints;
                if (distanceBetweenPoints(coordinate, curr) < distance) {
                  distance = distanceBetweenPoints(coordinate, curr);
                  return curr;
                }
                return acc;
              });
              return closest;
            } else if (searchType === 'grid') {
              var originWp = this._activeVenue.getClosestWaypointToCoordinate(coordinate, mapWps);
              return this._activeVenue.getClosestWaypointInArrayToWaypoint(originWp, wps);
            }
          }
        }
        return null;
      }
    }, {
      key: 'highlightUnitsInZone',
      value: function highlightUnitsInZone(zone, style) {
        var _this4 = this;

        if (style && style.constructor === jmap.Style) {
          var wps = this.getWaypointsInZone(zone);
          var units = wps.map(function (wp) {
            return _this4._control.getUnitFromWaypoint(wp);
          }).filter(function (a) {
            return a;
          });
          this._control.styleShapes(units, style);
        }
        return this;
      }
    }], [{
      key: '_getAreaOfPolygon',
      value: function _getAreaOfPolygon(polygon) {
        if (polygon.baseTypeName === 'Polygon' && polygon.points) {
          var area = polygon.points.reduce(function (acc, p1, i, points) {
            // If previous point is unavailable, use last point.
            var p2 = points[i - 1 > -1 ? i - 1 : points.length - 1];
            return acc + p1[0] * p2[1] - p1[1] * p2[0];
          }, 0);

          // if points are given in reverse order, you'll get an errant negative area
          return Math.abs(area / 2);
        }
        return null;
      }
    }, {
      key: '_createConvexHull',
      value: function _createConvexHull(points) {
        if (Array.isArray(points)) {
          // sort points in ascending order of x coordinate,
          // then by ascending order of y coordinate if x coordinates are equal
          points.sort(function (a, b) {
            return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
          });

          // gets second to last/last element in array
          var penultimate = function penultimate(array) {
            return array[array.length - 2];
          };
          var last = function last(array) {
            return array[array.length - 1];
          };

          var fn = function fn(set) {
            var array = [];
            set.forEach(function (point) {
              while (array.length >= 2 && ZoneKit.cross(penultimate(array), last(array), point) <= 0) {
                array.pop();
              }
              array.push(point);
            });
            array.pop();
            return array;
          };

          // gets lower and upper bounds of convex hull
          var lower = fn(points);
          var upper = fn(points.reverse());

          return lower.concat(upper);
        }
        return null;
      }
    }, {
      key: 'cross',
      value: function cross(origin, center, end) {
        var a = (origin[0] - end[0]) * (center[1] - end[1]);
        var b = (origin[1] - end[1]) * (center[0] - end[0]);
        return a - b;
      }
    }]);

    return ZoneKit;
  }();

  module.exports = ZoneKit;
});
//# sourceMappingURL=ZoneKit.js.map