(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module', './Asset', 'gsap/BezierPlugin'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, require('./Asset'), require('gsap/BezierPlugin'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, global.Asset, global.BezierPlugin);
    global.AssetKit = mod.exports;
  }
})(this, function (module, _Asset) {
  'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _global = global || window;

  /**
   * @class
   * @access public
   * @desc - Creates a new AssetKit, where users can create, read, update and remove Assets
   */

  var AssetKit = function () {

    /**
     * @access public
     * @desc - Creates a new AssetKit
     * @param {jmap.JController} control - The controller for the map instance
     * where assets are to be placed
     */
    function AssetKit(control) {
      _classCallCheck(this, AssetKit);

      // make control private
      if (control instanceof global.jmap.JController === false) {
        throw new Error('DeviceKit uses JController as its first argument.');
      }
      this._control = control;

      // assets are managed in two dictionaries - type and id - for quicker retrieval
      this._typeDictionary = {};
      this._idDictionary = {};

      // assets that have been wayfound to using the autoreroute method are stored here
      // when an asset is moved, we check whether it's being watched and update the path if it is
      this._watchedAssets = [];
    }

    /**
     * @access private
     * @desc - Given a path and a speed, find the duration of time
     * that would complete the path with the given speed
     * @param {jmap.core.Path} path - The path we're checking
     * @param {Number} speed - the speed of the asset in question (given in pixels per second)
     */


    _createClass(AssetKit, [{
      key: '_addToDicts',
      value: function _addToDicts(asset) {
        if (asset && asset.isAsset()) {
          if (this._typeDictionary[asset._type] === undefined) this._typeDictionary[asset._type] = [];
          this._typeDictionary[asset._type].push(asset);
          this._idDictionary[asset.id] = asset;
        }
        return this;
      }
    }, {
      key: '_removeFromDicts',
      value: function _removeFromDicts(asset) {
        if (asset && asset.isAsset()) {
          // remove from dictionaries
          var typeList = this._typeDictionary[asset._type];
          if (typeList) {
            var assetIndex = typeList.indexOf(asset);
            typeList.splice(assetIndex, 1);
          }

          delete this._idDictionary[asset.id];

          // tidy up type dictionary
          delete this._typeDictionary[asset._type];
        }
        return this;
      }
    }, {
      key: '_playNextAnimation',
      value: function _playNextAnimation(asset, animation) {
        if (asset.isAsset() && animation && animation.constructor === jmap.Animation) {
          var currentTween = asset.animationQueue.shift();
          if (currentTween) {
            if (currentTween.vars.mapId !== asset.map.id) {
              var map = this._control.activeVenue.maps.getById(currentTween.vars.mapId);
              this._control.updateMovingObject(asset, { map: map });
            }
            currentTween.paused(false);
          } else {
            animation.onComplete();
          }
        }
        return this;
      }
    }, {
      key: '_wayfindToWatched',
      value: function _wayfindToWatched(asset) {
        var _this = this;

        if (asset && asset.isAsset() && asset.watched) {
          // update the wayfinding path to the final position of the asset
          var wp = this._getWaypointFromUserLocation();
          var assetWp = this._getWaypointFromAsset(asset);
          var path = this._control.wayfindBetweenWaypoints(wp, assetWp);
          path.forEach(function (p) {
            var currentPath = asset.wayfindingPath.paths.find(function (assetPath) {
              return assetPath.mapId === p.mapId && assetPath.updated === false;
            });
            if (currentPath) {
              currentPath.line.data = [p.points.map(function (waypoint) {
                return waypoint.coordinates;
              })];
              currentPath.line.updateGraphic();
              currentPath.updated = true;
            } else {
              // add a new line here
              var mapView = _this._control.stage.getMapViewById(p.mapId);
              var mapLayer = mapView.getMapLayerByName('Wayfinding-Path');
              var newLine = new _this._control.jungle.shape.Line({
                data: [p.points.map(function (waypoint) {
                  return waypoint.coordinates;
                })],
                stroke: parseInt(asset.wayfindingPath.pathStyle.stroke.replace('#', '0x'), 16),
                strokeWidth: asset.wayfindingPath.pathStyle.strokeWidth,
                strokeOpacity: asset.wayfindingPath.pathStyle.strokeOpacity
              });
              mapLayer.addShape(newLine);
              asset.wayfindingPath.paths.push({
                mapId: p.mapId,
                updated: true,
                line: newLine,
                points: newLine.data[0]
              });
              if (p.mapId === _this._control.currentMap.id) {
                _this._control.renderCurrentMapView();
              }
            }
            var unusedPaths = asset.wayfindingPath.paths.filter(function (wfp) {
              return wfp.updated = false;
            });
            unusedPaths.forEach(function (l) {
              return _this._control.stage.removeShape(l);
            });
          });
          asset.wayfindingPath.paths.forEach(function (p) {
            return p.updated = false;
          });
        }
        return this;
      }
    }, {
      key: '_getPathDistance',
      value: function _getPathDistance(_from, _to) {
        if (_from && _from.constructor === jmap.core.Waypoint && _to && _to.constructor === jmap.core.Waypoint) {
          var paths = this._control.wayfindBetweenWaypoints(_from, _to);
          var distance = 0;
          if (paths.length <= 0) return null;
          paths.forEach(function (path) {
            // create a line out of hte points on the path
            var data = [path.points.map(function (a) {
              return a.coordinates;
            })];
            var line = new _global.jungle.shape.Line({ data: data });
            distance += line.length;
          });
          return distance;
        }
        return null;
      }
    }, {
      key: '_assetUpdated',
      value: function _assetUpdated(asset) {
        if (asset && asset.isAsset() && typeof this._updateAssetCallback === 'function') {
          this._updateAssetCallback(asset);
        }
        return this;
      }
    }, {
      key: '_getWaypointFromPoint',
      value: function _getWaypointFromPoint(jMapPoint) {
        if (AssetKit._isJMapPoint(jMapPoint)) {
          var map = this._control.activeVenue.maps.getById(jMapPoint.mapId);
          return this._control.activeVenue.getClosestWaypointToCoordinatesOnMap([jMapPoint.x, jMapPoint.y], map);
        }
        return null;
      }
    }, {
      key: '_getWaypointFromAsset',
      value: function _getWaypointFromAsset(asset) {
        if (asset && asset.isAsset()) {
          var map = asset.map;
          return this._control.activeVenue.getClosestWaypointToCoordinatesOnMap(asset.position, map);
        }
        return null;
      }
    }, {
      key: '_getWaypointFromUserLocation',
      value: function _getWaypointFromUserLocation() {
        var _control$userLocation = _slicedToArray(this._control.userLocation.position, 2),
            x = _control$userLocation[0],
            y = _control$userLocation[1];

        var jMapPoint = {
          x: x,
          y: y,
          mapId: this._control.userLocation.map.id
        };
        return this._getWaypointFromPoint(jMapPoint);
      }
    }, {
      key: '_getAllAssets',
      value: function _getAllAssets() {
        var _this2 = this;

        var assets = [];
        Object.keys(this._typeDictionary).forEach(function (type) {
          assets = assets.concat(_this2._typeDictionary[type]);
        });
        return assets;
      }
    }, {
      key: '_createPathTween',
      value: function _createPathTween(path, asset, animation) {
        var _this3 = this;

        if (asset.isAsset() && animation && animation.constructor === jmap.Animation) {
          var values = path.points.map(function (a) {
            return { x: a.coordinates[0], y: a.coordinates[1] };
          });
          var duration = animation.duration * 1000 || AssetKit._getPathDuration(path, asset.speed) * 1000;
          var tempItem = Object.assign({}, values[0]);

          var tween = _global.TweenLite.to(tempItem, duration / 1000, {
            bezier: { curviness: 0, values: values },
            mapId: path.mapId,
            onUpdate: function onUpdate(a, tI) {
              a.position = [tI.x, tI.y];
              animation.onUpdate();
            },
            onComplete: function onComplete(a) {
              if (a.watched && a.wayfindingPath.interval) {
                window.clearInterval(a.wayfindingPath.interval);
              }
              _this3._wayfindToWatched(a);
              _this3._assetUpdated(a);
              _this3._playNextAnimation(a, animation);
            },
            onUpdateParams: [asset, tempItem],
            onCompleteParams: [asset, tempItem],
            paused: true,
            ease: _global.Linear.easeNone
          });
          return tween;
        }
        return null;
      }
    }, {
      key: '_enableTapHandler',
      value: function _enableTapHandler(type, cb) {
        var _this4 = this;

        if (typeof type === 'string' && typeof cb === 'function') {
          if (['Tap', 'DoubleTap'].indexOf(type) > -1) {
            this._control.stage.events['add' + type + 'Handler'](function (event) {
              var layer = _this4._control.currentMapView.guaranteeMapLayer('Movable-Items');
              var items = layer.getMovingObjects().filter(function (a) {
                return a.assetKit !== undefined;
              });
              // Global touch point

              var _control$stage$__getX = _this4._control.stage.__getXY(event),
                  _control$stage$__getX2 = _slicedToArray(_control$stage$__getX, 2),
                  x = _control$stage$__getX2[0],
                  y = _control$stage$__getX2[1];

              // Make local to map
              event.localPoint = _this4._control.stage.getMapPointFromViewPortPoint([x, y]);
              // Find item that was touched
              var item = items.find(function (i) {
                return i.containsPoint(event.localPoint);
              });
              // Run layer method on interaction, pass item & event
              if (item && cb) cb(item, event);
            });
          }
        }
        return this;
      }
    }, {
      key: 'createAsset',
      value: function createAsset(assetConfig) {
        var _this5 = this;

        var _batch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (assetConfig) {
          if (Array.isArray(assetConfig)) {
            var assets = assetConfig.map(function (a) {
              return _this5.createAsset(a, true);
            });

            this._control.renderCurrentMapView();
            return assets;
          }

          if ((typeof assetConfig === 'undefined' ? 'undefined' : _typeof(assetConfig)) === 'object') {
            var c = Object.assign({}, assetConfig);
            c.map = assetConfig.map || this._control.currentMap;
            if (c.snapToGrid || c.snapToGrid === undefined) {
              var _c$position = _slicedToArray(c.position, 2),
                  x = _c$position[0],
                  y = _c$position[1];

              var jMapPoint = {
                x: x,
                y: y,
                mapId: c.map.id
              };
              c.position = this._getWaypointFromPoint(jMapPoint).coordinates;
            }
            var asset = new _Asset(c, this);
            // ensure that the specified map has been parsed
            this._control.parseMap(c.map);

            var mapView = this._control.stage.getMapViewById(c.map.id);
            var mapLayer = mapView.guaranteeMapLayer('Movable-Items');

            mapLayer.addMovingObject(asset);
            if (!_batch) this._control.renderCurrentMapView();

            this._addToDicts(asset);
            return asset;
          }
        }
        return null;
      }
    }, {
      key: 'updateAsset',
      value: function updateAsset(asset) {
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var animation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new jmap.Animation({});

        if (asset && asset.isAsset()) {
          if (config.position || config.mapId) {
            var _ref = config.position || asset.position,
                _ref2 = _slicedToArray(_ref, 2),
                x = _ref2[0],
                y = _ref2[1];

            var mapId = config.mapId || asset.map.id;
            var jMapPoint = { x: x, y: y, mapId: mapId };
            this.updateAssetWithPosition(asset, jMapPoint, animation);
            delete config.position;
            delete config.mapId;
          }
          if (config !== {}) this._control.updateMovingObject(asset, config, animation);
          return this;
        }
        return null;
      }
    }, {
      key: 'updateAssetWithPosition',
      value: function updateAssetWithPosition(asset, jMapPoint) {
        var _this6 = this;

        var animation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new jmap.Animation();

        if (asset && asset.isAsset() && AssetKit._isJMapPoint(jMapPoint)) {
          asset.animationQueue = [];
          if (asset.watched && typeof asset.wayfindingPath.rerouteInterval === 'number') {
            asset.wayfindingPath.interval = window.setInterval(function () {
              _this6._wayfindToWatched(asset);
            }, asset.wayfindingPath.rerouteInterval);
          }
          // check whether animation should follow the waypoint grid
          if (asset.meta.snapToGrid) {
            var assetWaypoint = this._getWaypointFromAsset(asset);
            var waypoint = this._getWaypointFromPoint(jMapPoint);
            var paths = this._control.wayfindBetweenWaypoints(assetWaypoint, waypoint);
            // loop through each map path and create an animation
            paths.forEach(function (path) {
              var pathTween = _this6._createPathTween(path, asset, animation);
              asset.animationQueue.push(pathTween);
            });
            this._playNextAnimation(asset, animation);
          } else {
            animation.onComplete = function () {
              _this6._wayfindToWatched(asset);
              _this6._assetUpdated(asset);
            };
            asset.moveToPosition([jMapPoint.x, jMapPoint.y], animation);
          }
          return asset;
        }
        return null;
      }
    }, {
      key: 'getNearestAssetToPoint',
      value: function getNearestAssetToPoint(jMapPoint, assets) {
        var _this7 = this;

        if (AssetKit._isJMapPoint(jMapPoint)) {
          var assetArray = assets || this._getAllAssets();
          var wp = this._getWaypointFromPoint(jMapPoint);
          var tempDist = Infinity;
          var closestAsset = null;
          assetArray.forEach(function (asset) {
            var d = _this7._getPathDistance(wp, _this7._getWaypointFromAsset(asset));
            if (d !== null && d < tempDist) {
              tempDist = d;
              closestAsset = asset;
            }
          });
          return closestAsset;
        }
        return null;
      }
    }, {
      key: 'getNearestAssetOfTypeToPoint',
      value: function getNearestAssetOfTypeToPoint(type, jMapPoint) {
        if (typeof type === 'string' && AssetKit._isJMapPoint(jMapPoint)) {
          var assetArray = this.getAssetsByType(type);
          return this.getNearestAssetToPoint(jMapPoint, assetArray);
        }
        return null;
      }
    }, {
      key: 'showAssetsOfType',
      value: function showAssetsOfType(type) {
        if (typeof type === 'string' && Array.isArray(this._typeDictionary[type])) {
          this._typeDictionary[type].forEach(function (a) {
            a.visible = true;
          });
        }
        return this;
      }
    }, {
      key: 'hideAssetsOfType',
      value: function hideAssetsOfType(type) {
        if (typeof type === 'string' && Array.isArray(this._typeDictionary[type])) {
          if (Array.isArray(this._typeDictionary[type])) {
            this._typeDictionary[type].forEach(function (a) {
              a.visible = false;
            });
          }
        }
        return this;
      }
    }, {
      key: 'removeAsset',
      value: function removeAsset(asset) {
        if (asset && asset.isAsset()) {
          this._control.removeMovingObject(asset);

          // remove from the watched assets
          this._watchedAssets = this._watchedAssets.filter(function (a) {
            return a !== asset;
          });

          this._removeFromDicts(asset);
        }
        return this;
      }
    }, {
      key: 'getAssetById',
      value: function getAssetById(id) {
        return this._idDictionary[id] || null;
      }
    }, {
      key: 'getAssetsByType',
      value: function getAssetsByType(type) {
        return this._typeDictionary[type] || [];
      }
    }, {
      key: 'wayfindToAssetFromPoint',
      value: function wayfindToAssetFromPoint(asset, jMapPoint, pathStyle) {
        if (asset && asset.isAsset() && AssetKit._isJMapPoint(jMapPoint)) {
          // wayfind between points and return path
          var wp = this._getWaypointFromPoint(jMapPoint);
          var assetWp = this._getWaypointFromAsset(asset);
          if (wp.constructor === jmap.core.Waypoint && assetWp.constructor === jmap.core.Waypoint) {
            var path = this._control.wayfindBetweenWaypoints(wp, assetWp);
            var style = pathStyle || this._control.defaultPathStyle;
            // draw path
            this._control.drawWayfindingPath(path, style);
          }
        }
        return this;
      }
    }, {
      key: 'wayfindFromUserLocationToAssetWithAutoReroute',
      value: function wayfindFromUserLocationToAssetWithAutoReroute(asset, pathStyle) {
        var _this8 = this;

        var rerouteInterval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        if (asset && asset.isAsset()) {
          var wp = this._getWaypointFromUserLocation();
          var assetWp = this._getWaypointFromAsset(asset);

          if (wp.constructor === jmap.core.Waypoint && assetWp.constructor === jmap.core.Waypoint) {
            var path = this._control.wayfindBetweenWaypoints(wp, assetWp);
            asset.watched = true;
            var paths = this._control.wayfindBetweenWaypoints(wp, assetWp).map(function (p) {
              return {
                updated: false,
                mapId: p.mapId,
                points: p.points.map(function (pointsWp) {
                  return pointsWp.coordinates;
                })
              };
            });

            asset.wayfindingPath = {
              paths: paths,
              pathStyle: pathStyle,
              rerouteInterval: rerouteInterval
            };
            this._control.drawWayfindingPath(path, pathStyle);
            // assign each new line to the watched asset
            paths.forEach(function (p) {
              var mapView = _this8._control.stage.getMapViewById(p.mapId);
              var lines = mapView.getMapLayerByName('Wayfinding-Path').shapes;
              p.line = lines.find(function (l) {
                return AssetKit._comparePath(l.data[0], p.points);
              });
            });
          }
        }
        return this;
      }
    }, {
      key: 'wayfindToNearestAssetOfType',
      value: function wayfindToNearestAssetOfType(type, jMapPoint) {
        if (typeof type === 'string' && AssetKit._isJMapPoint(jMapPoint)) {
          // find nearest waypoint to position
          var closest = this.getNearestAssetOfTypeToPoint(type, jMapPoint);
          // wayfind to this asset
          if (closest) {
            this.wayfindToAssetFromPoint(closest, jMapPoint);
          }
        }
        return this;
      }
    }, {
      key: 'clearWayfindingPath',
      value: function clearWayfindingPath() {
        // ensure that no assets are now being watched
        var assets = this._getAllAssets();
        assets.forEach(function (a) {
          return a.watched = false;
        });
        this._control.clearWayfindingPath();
        return this;
      }
    }, {
      key: 'enableAssetTap',
      value: function enableAssetTap(cb) {
        this._enableTapHandler('Tap', cb);
        return this;
      }
    }, {
      key: 'enableAssetDoubleTap',
      value: function enableAssetDoubleTap(cb) {
        this._enableTapHandler('DoubleTap', cb);
        return this;
      }
    }, {
      key: 'disableAssetTap',
      value: function disableAssetTap(cb) {
        var callBackList = this._control.stage.events.tapHandlers;
        var cbIndex = callBackList.indexOf(cb);
        callBackList.splice(cbIndex, 1);
        return this;
      }
    }, {
      key: 'disableAssetDoubleTap',
      value: function disableAssetDoubleTap(cb) {
        var callBackList = this._control.stage.events.doubleTapHandlers;
        var cbIndex = callBackList.indexOf(cb);
        callBackList.splice(cbIndex, 1);
        return this;
      }
    }, {
      key: 'wayfindAssetUpdated',
      value: function wayfindAssetUpdated(cb) {
        this._updateAssetCallback = cb;
        return this;
      }
    }], [{
      key: '_getPathDuration',
      value: function _getPathDuration(path, speed) {
        if (path && typeof speed === 'number') {
          var data = [path.points.map(function (a) {
            return a.coordinates;
          })];
          var line = new _global.jungle.shape.Line({ data: data });
          return line.length / speed;
        }
        return null;
      }
    }, {
      key: '_comparePath',
      value: function _comparePath(path1, path2) {
        if (Array.isArray(path1) && Array.isArray(path2) && path1.length === path2.length) {
          return path1.reduce(function (acc, curr, i) {
            if (acc) {
              if (curr[0] === path2[i][0] && curr[1] === path2[i][1]) return true;
            }
            return false;
          }, true);
        }
        return false;
      }
    }, {
      key: '_isJMapPoint',
      value: function _isJMapPoint(j) {
        return j && typeof j.x === 'number' && typeof j.y === 'number' && typeof j.mapId === 'number';
      }
    }]);

    return AssetKit;
  }();

  /**
   * A point that describes an x, y coordinate with the mapId that it's on
   * @typedef {Object} JMapPoint
   * @property {number} x - The X coordinate of the point
   * @property {number} y - The y coordinate of the point
   * @property {number} mapId - The ID of the map that the coordinates are on
   */

  /**
   * The configuration object for the creation and update of an asset
   * @typedef {Object} assetConfig
   * @property {Map} map - The map the asset will be placed on
   * @property {number[]} position - Coordinates of the asset (as [x, y])
   * @property {number} [id=0] - The ID of the asset
   * @property {string} [name=''] - The name of the asset
   * @property {number} [speed=100] - How quickly the asset should move to new coordinates (pixels
   * per second)
   * @property {number} [orientation=0] - The orientation of the asset's icon
   * @property {string} [type="_default"] - The type of asset
   * @property {boolean} [snapToGrid=false] - Whether the asset should follow the waypoint grid
   * @property {boolean} [snapToWaypoint=false] - Whether the asset should snap to waypoints when
   * repositioning
   *
   * @property {number} [width=20] - The width of the icon
   * @property {number} [height=20] - The height of the icon
   * @property {string} [url] - The URL of the image to be used as the asset's icon
   * @property {boolean} [scaleWithMap=true] - Whether the asset's icon should scale with the map
   * @property {boolean} [rotateWithMap=true] - Whether the asset's icon should rotate with the map
   * @property {number[]} [anchor] - The origin point of the icon, with the two values being
   * percentages of the sprite's dimensions (between 0 and 1)
   * @property {string} [iconColor] - If no url is provided for the icon, the colour of the default
   * icon
   *
   * @property {number} [confidenceMax] - The maximum radius of the confidence circle (in pixels)
   * @property {number} [confidencePercent] - The confidence in the position of the item (between 0
   * and 1). 0 will hide the confidence circle; 1 will display the full circle
   * @property {string} [confidenceColor] - The color of the confidence circle in hexadecimal format
   * @property {number} [confidenceAlpha] - The transparency of the confidence circle (between 0 and
   * 1)
   *
   * @property {string} [pulseColor] - The color of the pulse circle
   * @property {number} [pulseStartAlpha] - The starting opacity of the pulse circle (between 0 and 1)
   * @property {number} [pulseEndAlpha] - The ending opacity of the pulse circle (between 0 and 1)
   * @property {number} [pulseDuration] - The length of time of the pulse animation (in seconds)
   * @property {number} [pulseDelay] - The delay between pulse animation (in seconds)
   * @property {boolean} [pulseVisible] - Whether the pulse should be visible
   */

  module.exports = AssetKit;
});
//# sourceMappingURL=AssetKit.js.map