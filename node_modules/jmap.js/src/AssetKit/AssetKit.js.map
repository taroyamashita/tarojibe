{"version":3,"sources":["../src/AssetKit.js"],"names":["_Asset","_global","global","window","AssetKit","control","jmap","JController","Error","_control","_typeDictionary","_idDictionary","_watchedAssets","asset","isAsset","_type","undefined","push","id","typeList","assetIndex","indexOf","splice","animation","constructor","Animation","currentTween","animationQueue","shift","vars","mapId","map","activeVenue","maps","getById","updateMovingObject","paused","onComplete","watched","wp","_getWaypointFromUserLocation","assetWp","_getWaypointFromAsset","path","wayfindBetweenWaypoints","forEach","currentPath","wayfindingPath","paths","find","assetPath","p","updated","line","data","points","waypoint","coordinates","updateGraphic","mapView","stage","getMapViewById","mapLayer","getMapLayerByName","newLine","jungle","shape","Line","stroke","parseInt","pathStyle","replace","strokeWidth","strokeOpacity","addShape","currentMap","renderCurrentMapView","unusedPaths","filter","wfp","removeShape","l","_from","_to","core","Waypoint","distance","length","a","_updateAssetCallback","jMapPoint","_isJMapPoint","getClosestWaypointToCoordinatesOnMap","x","y","position","userLocation","_getWaypointFromPoint","assets","Object","keys","concat","type","values","duration","_getPathDuration","speed","tempItem","assign","tween","TweenLite","to","bezier","curviness","onUpdate","tI","interval","clearInterval","_wayfindToWatched","_assetUpdated","_playNextAnimation","onUpdateParams","onCompleteParams","ease","Linear","easeNone","cb","events","layer","currentMapView","guaranteeMapLayer","items","getMovingObjects","assetKit","__getXY","event","localPoint","getMapPointFromViewPortPoint","item","i","containsPoint","assetConfig","_batch","Array","isArray","createAsset","c","snapToGrid","parseMap","addMovingObject","_addToDicts","config","updateAssetWithPosition","rerouteInterval","setInterval","meta","assetWaypoint","pathTween","_createPathTween","moveToPosition","assetArray","_getAllAssets","tempDist","Infinity","closestAsset","d","_getPathDistance","getAssetsByType","getNearestAssetToPoint","visible","removeMovingObject","_removeFromDicts","style","defaultPathStyle","drawWayfindingPath","pointsWp","lines","shapes","_comparePath","closest","getNearestAssetOfTypeToPoint","wayfindToAssetFromPoint","clearWayfindingPath","_enableTapHandler","callBackList","tapHandlers","cbIndex","doubleTapHandlers","path1","path2","reduce","acc","curr","j","module","exports"],"mappings":"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","file":"AssetKit.js","sourcesContent":["const _Asset = require('./Asset')\nrequire('gsap/BezierPlugin')\n\nconst _global = global || window\n\n/**\n * @class\n * @access public\n * @desc - Creates a new AssetKit, where users can create, read, update and remove Assets\n */\nclass AssetKit {\n\n  /**\n   * @access public\n   * @desc - Creates a new AssetKit\n   * @param {jmap.JController} control - The controller for the map instance\n   * where assets are to be placed\n   */\n  constructor(control) {\n    // make control private\n    if (control instanceof global.jmap.JController === false) {\n      throw new Error('DeviceKit uses JController as its first argument.')\n    }\n    this._control = control\n\n    // assets are managed in two dictionaries - type and id - for quicker retrieval\n    this._typeDictionary = {}\n    this._idDictionary = {}\n\n    // assets that have been wayfound to using the autoreroute method are stored here\n    // when an asset is moved, we check whether it's being watched and update the path if it is\n    this._watchedAssets = []\n  }\n\n  /**\n   * @access private\n   * @desc - Given a path and a speed, find the duration of time\n   * that would complete the path with the given speed\n   * @param {jmap.core.Path} path - The path we're checking\n   * @param {Number} speed - the speed of the asset in question (given in pixels per second)\n   */\n  static _getPathDuration(path, speed) {\n    if (path && typeof speed === 'number') {\n      const data = [path.points.map(a => a.coordinates)]\n      const line = new _global.jungle.shape.Line({ data })\n      return line.length / speed\n    }\n    return null\n  }\n\n  /**\n   * @access private\n   * @desc - Return whether two paths are equal\n   * @param {Array[]} path1 - The first path\n   * @param {Array[]} path2 - The second path\n   * @return {Boolean} Whether the two paths are equal\n   */\n  static _comparePath(path1, path2) {\n    if (Array.isArray(path1) && Array.isArray(path2) && (path1.length === path2.length)) {\n      return path1.reduce((acc, curr, i) => {\n        if (acc) {\n          if (curr[0] === path2[i][0] && curr[1] === path2[i][1]) return true\n        }\n        return false\n      }, true)\n    }\n    return false\n  }\n\n  /**\n   * @access private\n   * @desc - Return a boolean for whether a passed in variable is a well formed jMapPoint\n   * @param {Object} j - The variable to check\n   * @return {Boolean} - Whether the passed in variable is a well formed jMapPoint\n   */\n  static _isJMapPoint(j) {\n    return j && typeof j.x === 'number' && typeof j.y === 'number' && typeof j.mapId === 'number'\n  }\n\n  /**\n   * @access private\n   * @desc - Adds a given asset to the asset kit's dictionaries\n   * @param {Asset} asset - The asset being added to the dictionaries\n   * @return {AssetKit} - The current AssetKit\n   */\n  _addToDicts(asset) {\n    if (asset && asset.isAsset()) {\n      if (this._typeDictionary[asset._type] === undefined) this._typeDictionary[asset._type] = []\n      this._typeDictionary[asset._type].push(asset)\n      this._idDictionary[asset.id] = asset\n    }\n    return this\n  }\n\n  /**\n   * @access private\n   * @desc - Removes a given asset from the asset kit's dictionaries\n   * @param {Asset} asset - The asset being removed from the dictionaries\n   * @return {AssetKit} - The current AssetKit\n   */\n  _removeFromDicts(asset) {\n    if (asset && asset.isAsset()) {\n      // remove from dictionaries\n      const typeList = this._typeDictionary[asset._type]\n      if (typeList) {\n        const assetIndex = typeList.indexOf(asset)\n        typeList.splice(assetIndex, 1)\n      }\n\n      delete this._idDictionary[asset.id]\n\n      // tidy up type dictionary\n      delete this._typeDictionary[asset._type]\n    }\n    return this\n  }\n\n  /**\n   * @access private\n   * @desc - For a given asset, play the next animation in its queue\n   * @param {Asset} asset - The asset being animated\n   * @param {jmap.Animation} animation - the asset's animation, so that we can\n   * run the onComplete if this is the last section of a longer animation\n   * @return {AssetKit} - The current AssetKit\n   */\n  _playNextAnimation(asset, animation) {\n    if (asset.isAsset() && animation && animation.constructor === jmap.Animation) {\n      const currentTween = asset.animationQueue.shift()\n      if (currentTween) {\n        if (currentTween.vars.mapId !== asset.map.id) {\n          const map = this._control.activeVenue.maps.getById(currentTween.vars.mapId)\n          this._control.updateMovingObject(asset, { map })\n        }\n        currentTween.paused(false)\n      } else {\n        animation.onComplete()\n      }\n    }\n    return this\n  }\n\n  /**\n   * @access private\n   * @desc - Given a specific asset, check if it's being watched. If it is, redraw its wayfinding\n   * path to the asset's new location\n   * @param {Asset} asset - The asset to check\n   * @return {AssetKit} - The current AssetKit\n   */\n  _wayfindToWatched(asset) {\n    if (asset && asset.isAsset() && asset.watched) {\n      // update the wayfinding path to the final position of the asset\n      const wp = this._getWaypointFromUserLocation()\n      const assetWp = this._getWaypointFromAsset(asset)\n      const path = this._control.wayfindBetweenWaypoints(wp, assetWp)\n      path.forEach(p => {\n        const currentPath = asset.wayfindingPath.paths.find(assetPath => (\n          assetPath.mapId === p.mapId && assetPath.updated === false\n        ))\n        if (currentPath) {\n          currentPath.line.data = [p.points.map(waypoint => waypoint.coordinates)]\n          currentPath.line.updateGraphic()\n          currentPath.updated = true\n        } else {\n          // add a new line here\n          const mapView = this._control.stage.getMapViewById(p.mapId)\n          const mapLayer = mapView.getMapLayerByName('Wayfinding-Path')\n          const newLine = new this._control.jungle.shape.Line({\n            data: [p.points.map(waypoint => waypoint.coordinates)],\n            stroke: parseInt(asset.wayfindingPath.pathStyle.stroke.replace('#', '0x'), 16),\n            strokeWidth: asset.wayfindingPath.pathStyle.strokeWidth,\n            strokeOpacity: asset.wayfindingPath.pathStyle.strokeOpacity,\n          })\n          mapLayer.addShape(newLine)\n          asset.wayfindingPath.paths.push({\n            mapId: p.mapId,\n            updated: true,\n            line: newLine,\n            points: newLine.data[0],\n          })\n          if (p.mapId === this._control.currentMap.id) {\n            this._control.renderCurrentMapView()\n          }\n        }\n        const unusedPaths = asset.wayfindingPath.paths.filter(wfp => (wfp.updated = false))\n        unusedPaths.forEach(l => this._control.stage.removeShape(l))\n      })\n      asset.wayfindingPath.paths.forEach(p => (p.updated = false))\n    }\n    return this\n  }\n\n\n  /**\n   * @access private\n   * @desc - Calculate the distance between two waypoints by calculating the sum of\n   * the path segments between them\n   * @param {jmap.core.Waypoint} _from - The origin waypoint\n   * @param {jmap.core.Waypoint} _to - The destination waypoint\n   * @return {Number} - The total distance between the waypoints\n   */\n  _getPathDistance(_from, _to) {\n    if (_from && _from.constructor === jmap.core.Waypoint &&\n        _to && _to.constructor === jmap.core.Waypoint) {\n      const paths = this._control.wayfindBetweenWaypoints(_from, _to)\n      let distance = 0\n      if (paths.length <= 0) return null\n      paths.forEach(path => {\n        // create a line out of hte points on the path\n        const data = [path.points.map(a => a.coordinates)]\n        const line = new _global.jungle.shape.Line({ data })\n        distance += line.length\n      })\n      return distance\n    }\n    return null\n  }\n\n  /**\n   * @access private\n   * @desc - Run when an asset's position is updated\n   * @param {Asset} asset - The asset that was updated\n   * @return {AssetKit} - The current AssetKit\n   */\n  _assetUpdated(asset) {\n    if (asset && asset.isAsset() && typeof this._updateAssetCallback === 'function') {\n      this._updateAssetCallback(asset)\n    }\n    return this\n  }\n\n  /**\n   * @access private\n   * @desc - Return the closest waypoint to a given point on a map\n   * @param {jMapPoint} jMapPoint - The point on the map that we're searching with\n   * @return {jmap.core.Waypoint} - The closest waypoint to the passed in point\n   */\n  _getWaypointFromPoint(jMapPoint) {\n    if (AssetKit._isJMapPoint(jMapPoint)) {\n      const map = this._control.activeVenue.maps.getById(jMapPoint.mapId)\n      return this._control.activeVenue\n        .getClosestWaypointToCoordinatesOnMap([jMapPoint.x, jMapPoint.y], map)\n    }\n    return null\n  }\n\n  /**\n   * @access private\n   * @desc - Return the closest waypoint to a given asset on a map\n   * @param {Asset} asset - The asset on the map that we're searching with\n   * @return {jmap.core.Waypoint} - The closest waypoint to the passed in asset\n   */\n  _getWaypointFromAsset(asset) {\n    if (asset && asset.isAsset()) {\n      const map = asset.map\n      return this._control.activeVenue\n        .getClosestWaypointToCoordinatesOnMap(asset.position, map)\n    }\n    return null\n  }\n\n  /**\n   * @access private\n   * @desc - Return the closest waypoint to current user location\n   * @param {Asset} asset - The asset on the map that we're searching with\n   * @return {jmap.core.Waypoint} - The closest waypoint to the passed in asset\n   */\n  _getWaypointFromUserLocation() {\n    const [x, y] = this._control.userLocation.position\n    const jMapPoint = {\n      x,\n      y,\n      mapId: this._control.userLocation.map.id,\n    }\n    return this._getWaypointFromPoint(jMapPoint)\n  }\n\n  /**\n   * @access private\n   * @desc - Return all assets in the current building\n   * @return {Asset[]} - An array of all the assets in the current building\n   */\n  _getAllAssets() {\n    let assets = []\n    Object.keys(this._typeDictionary).forEach(type => {\n      assets = assets.concat(this._typeDictionary[type])\n    })\n    return assets\n  }\n\n  /**\n   * @access private\n   * @desc - Create a tween based on a path and an asset\n   * @param {jmap.core.Path} path - The path to tween along\n   * @param {Asset} asset - The asset we're tweening\n   * @param {jmap.Animation} animation - The animation to base the tween on\n   * @return {TweenLite} - The created tween\n   */\n  _createPathTween(path, asset, animation) {\n    if (asset.isAsset() && animation && animation.constructor === jmap.Animation) {\n      const values = path.points.map(a => ({ x: a.coordinates[0], y: a.coordinates[1] }))\n      const duration = animation.duration * 1000 ||\n                       AssetKit._getPathDuration(path, asset.speed) * 1000\n      const tempItem = Object.assign({}, values[0])\n\n      const tween = _global.TweenLite.to(tempItem, duration / 1000, {\n        bezier: { curviness: 0, values },\n        mapId: path.mapId,\n        onUpdate: (a, tI) => {\n          a.position = [tI.x, tI.y]\n          animation.onUpdate()\n        },\n        onComplete: a => {\n          if (a.watched && a.wayfindingPath.interval) {\n            window.clearInterval(a.wayfindingPath.interval)\n          }\n          this._wayfindToWatched(a)\n          this._assetUpdated(a)\n          this._playNextAnimation(a, animation)\n        },\n        onUpdateParams: [asset, tempItem],\n        onCompleteParams: [asset, tempItem],\n        paused: true,\n        ease: _global.Linear.easeNone,\n      })\n      return tween\n    }\n    return null\n  }\n\n  /**\n   * @access private\n   * @desc - Add a tap handler of a specific type ('Tap' or 'DoubleTap') to the stage\n   * and run the callback if the tapped coordinates intersect with an asset\n   * @param {String} type - What tap event to listen to: 'Tap' || 'DoubleTap'\n   * @param {Function} cb - The callback that will be run on tap\n   * Accepts two parameters: asset, event\n   * @return {AssetKit} - The current AssetKit\n   */\n  _enableTapHandler(type, cb) {\n    if (typeof type === 'string' && typeof cb === 'function') {\n      if (['Tap', 'DoubleTap'].indexOf(type) > -1) {\n        this._control.stage.events[`add${type}Handler`](event => {\n          const layer = this._control.currentMapView.guaranteeMapLayer('Movable-Items')\n          const items = layer.getMovingObjects().filter(a => a.assetKit !== undefined)\n          // Global touch point\n          const [x, y] = this._control.stage.__getXY(event)\n          // Make local to map\n          event.localPoint = this._control.stage.getMapPointFromViewPortPoint([x, y])\n          // Find item that was touched\n          const item = items.find(i => i.containsPoint(event.localPoint))\n          // Run layer method on interaction, pass item & event\n          if (item && cb) cb(item, event)\n        })\n      }\n    }\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Create an asset based on the configuration passed in\n   * @param {assetConfig} assetConfig - The configuration object for the asset\n   * @return {Asset} - The created asset\n   */\n  createAsset(assetConfig, _batch = false) {\n    if (assetConfig) {\n      if (Array.isArray(assetConfig)) {\n        const assets = assetConfig.map(a => this.createAsset(a, true))\n\n        this._control.renderCurrentMapView()\n        return assets\n      }\n\n      if (typeof assetConfig === 'object') {\n        const c = Object.assign({}, assetConfig)\n        c.map = assetConfig.map || this._control.currentMap\n        if (c.snapToGrid || c.snapToGrid === undefined) {\n          const [x, y] = c.position\n          const jMapPoint = {\n            x,\n            y,\n            mapId: c.map.id,\n          }\n          c.position = this._getWaypointFromPoint(jMapPoint).coordinates\n        }\n        const asset = new _Asset(c, this)\n        // ensure that the specified map has been parsed\n        this._control.parseMap(c.map)\n\n        const mapView = this._control.stage.getMapViewById(c.map.id)\n        const mapLayer = mapView.guaranteeMapLayer('Movable-Items')\n\n        mapLayer.addMovingObject(asset)\n        if (!_batch) this._control.renderCurrentMapView()\n\n        this._addToDicts(asset)\n        return asset\n      }\n    }\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Update any properties of the asset that are passed in,\n   * animated using the animation passed in\n   * @param {Asset} asset - The asset that will be updated\n   * @param {assetConfig} config - An object containing any properties that you wish to update\n   * @param {jmap.Animation} [animation] - The way in which these properties should be\n   * animated, if it's possible to animate them\n   * @return {AssetKit} - The current asset kit\n   */\n  updateAsset(asset, config = {}, animation = new jmap.Animation({})) {\n    if (asset && asset.isAsset()) {\n      if (config.position || config.mapId) {\n        // update assets position on map\n        // this may include animating along the grid so is handled elsewhere\n        const [x, y] = config.position || asset.position\n        const mapId = config.mapId || asset.map.id\n        const jMapPoint = { x, y, mapId }\n        this.updateAssetWithPosition(asset, jMapPoint, animation)\n        delete config.position\n        delete config.mapId\n      }\n      if (config !== {}) this._control.updateMovingObject(asset, config, animation)\n      return this\n    }\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Update the position of an asset, using the provided animation\n   * @param {Asset} asset - The asset which will be moved\n   * @param {jMapPoint} jMapPoint - The new position and map ID for the asset\n   * @param {jmap.Animation} animation - How the asset should be animated as its updated\n   * @return {Asset} - The asset which has been moved\n   */\n  updateAssetWithPosition(asset, jMapPoint, animation = new jmap.Animation()) {\n    if (asset && asset.isAsset() && AssetKit._isJMapPoint(jMapPoint)) {\n      asset.animationQueue = []\n      if (asset.watched && typeof asset.wayfindingPath.rerouteInterval === 'number') {\n        asset.wayfindingPath.interval = window.setInterval(() => {\n          this._wayfindToWatched(asset)\n        }, asset.wayfindingPath.rerouteInterval)\n      }\n      // check whether animation should follow the waypoint grid\n      if (asset.meta.snapToGrid) {\n        const assetWaypoint = this._getWaypointFromAsset(asset)\n        const waypoint = this._getWaypointFromPoint(jMapPoint)\n        const paths = this._control.wayfindBetweenWaypoints(assetWaypoint, waypoint)\n        // loop through each map path and create an animation\n        paths.forEach(path => {\n          const pathTween = this._createPathTween(path, asset, animation)\n          asset.animationQueue.push(pathTween)\n        })\n        this._playNextAnimation(asset, animation)\n      } else {\n        animation.onComplete = () => {\n          this._wayfindToWatched(asset)\n          this._assetUpdated(asset)\n        }\n        asset.moveToPosition([jMapPoint.x, jMapPoint.y], animation)\n      }\n      return asset\n    }\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Return the nearest asset to a given point on a map.\n   * Accepts an optional parameter of an array of assets to search through. If not provided,\n   * search through all assets in given building\n   * @param {jMapPoint} jMapPoint - The point that you are searching with\n   * @param {Asset[]} [assets] - A subset of the building's assets to search through\n   * Defaults to using all assets\n   * @return {Asset} - The closest asset to the provided jMapPoint\n   */\n  getNearestAssetToPoint(jMapPoint, assets) {\n    if (AssetKit._isJMapPoint(jMapPoint)) {\n      const assetArray = assets || this._getAllAssets()\n      const wp = this._getWaypointFromPoint(jMapPoint)\n      let tempDist = Infinity\n      let closestAsset = null\n      assetArray.forEach(asset => {\n        const d = this._getPathDistance(wp, this._getWaypointFromAsset(asset))\n        if (d !== null && d < tempDist) {\n          tempDist = d\n          closestAsset = asset\n        }\n      })\n      return closestAsset\n    }\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Return the nearest asset of a specific type to a given point on a map.\n   * @param {string} type - The type of assets that we're searching for\n   * @param {jMapPoint} jMapPoint - The point that you are searching with\n   * @return {Asset} - The closest asset of the specific type to the provided jMapPoint\n   */\n  getNearestAssetOfTypeToPoint(type, jMapPoint) {\n    if (typeof type === 'string' && AssetKit._isJMapPoint(jMapPoint)) {\n      const assetArray = this.getAssetsByType(type)\n      return this.getNearestAssetToPoint(jMapPoint, assetArray)\n    }\n    return null\n  }\n\n  /**\n   * @access public\n   * @desc - Show all assets of a specific type\n   * @param {string} type - The type of assets that will be shown\n   * @return {AssetKit} - The current AssetKit\n   */\n  showAssetsOfType(type) {\n    if (typeof type === 'string' && Array.isArray(this._typeDictionary[type])) {\n      this._typeDictionary[type]\n        .forEach(a => {\n          a.visible = true\n        })\n    }\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Hide all assets of a specific type\n   * @param {string} type - The type of assets that will be hidden\n   * @return {AssetKit} - The current AssetKit\n   */\n  hideAssetsOfType(type) {\n    if (typeof type === 'string' && Array.isArray(this._typeDictionary[type])) {\n      if (Array.isArray(this._typeDictionary[type])) {\n        this._typeDictionary[type]\n          .forEach(a => {\n            a.visible = false\n          })\n      }\n    }\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Remove a specific asset\n   * @param {Asset} asset - The asset to be removed\n   * @return {AssetKit} - The current AssetKit\n   */\n  removeAsset(asset) {\n    if (asset && asset.isAsset()) {\n      this._control.removeMovingObject(asset)\n\n      // remove from the watched assets\n      this._watchedAssets = this._watchedAssets.filter(a => a !== asset)\n\n      this._removeFromDicts(asset)\n    }\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Return a specific asset by its ID\n   * @param {Number} id - The ID to search for\n   * @return {Asset} - The asset with the matching ID\n   */\n  getAssetById(id) {\n    return this._idDictionary[id] || null\n  }\n\n  /**\n   * @access public\n   * @desc - Return all assets of a specific type\n   * @param {string} type - The asset type to search for\n   * @return {Asset[]} - All assets with the matching type\n   */\n  getAssetsByType(type) {\n    return this._typeDictionary[type] || []\n  }\n\n  /**\n   * @access public\n   * @desc - Wayfind to a specific asset, given a point on the map\n   * @param {Asset} asset - The asset that we are wayfinding to\n   * @param {jMapPoint} jMapPoint - The point on the map that we're wayfinding from\n   * @param {jmap.Style} pathStyle - The path style\n   * @return {AssetKit} - The current AssetKit\n   */\n  wayfindToAssetFromPoint(asset, jMapPoint, pathStyle) {\n    if (asset && asset.isAsset() && AssetKit._isJMapPoint(jMapPoint)) {\n      // wayfind between points and return path\n      const wp = this._getWaypointFromPoint(jMapPoint)\n      const assetWp = this._getWaypointFromAsset(asset)\n      if (wp.constructor === jmap.core.Waypoint && assetWp.constructor === jmap.core.Waypoint) {\n        const path = this._control.wayfindBetweenWaypoints(wp, assetWp)\n        const style = pathStyle || this._control.defaultPathStyle\n        // draw path\n        this._control.drawWayfindingPath(path, style)\n      }\n    }\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Wayfind to a specific asset, given a point on the map and reroute if the asset moves\n   * @param {Asset} asset - The asset that we are wayfinding to\n   * @param {pathStyle} pathStyle - The path style\n   * @param {Number} [rerouteInterval=null] - How often the wayfinding path should be redrawn if\n   * the asset moves. If nothing is passed in, or null/false is passed in, the wayfinding path will\n   * not be\n   * redrawn\n   * @return {AssetKit} - The current AssetKit\n   */\n  wayfindFromUserLocationToAssetWithAutoReroute(asset, pathStyle, rerouteInterval = null) {\n    if (asset && asset.isAsset()) {\n      const wp = this._getWaypointFromUserLocation()\n      const assetWp = this._getWaypointFromAsset(asset)\n\n      if (wp.constructor === jmap.core.Waypoint && assetWp.constructor === jmap.core.Waypoint) {\n        const path = this._control.wayfindBetweenWaypoints(wp, assetWp)\n        asset.watched = true\n        const paths = this._control.wayfindBetweenWaypoints(wp, assetWp).map(p => (\n          {\n            updated: false,\n            mapId: p.mapId,\n            points: p.points.map(pointsWp => pointsWp.coordinates),\n          }\n        ))\n\n        asset.wayfindingPath = {\n          paths,\n          pathStyle,\n          rerouteInterval,\n        }\n        this._control.drawWayfindingPath(path, pathStyle)\n        // assign each new line to the watched asset\n        paths.forEach(p => {\n          const mapView = this._control.stage.getMapViewById(p.mapId)\n          const lines = mapView.getMapLayerByName('Wayfinding-Path').shapes\n          p.line = lines.find(l => AssetKit._comparePath(l.data[0], p.points))\n        })\n      }\n    }\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Wayfind to the nearest asset of the given type, given a point on the map\n   * @param {String} type - The type of asset that we want to route to\n   * @param {jMapPoint} jMapPoint - The point on the map that we're wayfinding from\n   * @return {AssetKit} - The current AssetKit\n   */\n  wayfindToNearestAssetOfType(type, jMapPoint) {\n    if (typeof type === 'string' && AssetKit._isJMapPoint(jMapPoint)) {\n      // find nearest waypoint to position\n      const closest = this.getNearestAssetOfTypeToPoint(type, jMapPoint)\n      // wayfind to this asset\n      if (closest) {\n        this.wayfindToAssetFromPoint(closest, jMapPoint)\n      }\n    }\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Clear any wayfinding paths on the map\n   * @return {AssetKit} - The current AssetKit\n   */\n  clearWayfindingPath() {\n    // ensure that no assets are now being watched\n    const assets = this._getAllAssets()\n    assets.forEach(a => (a.watched = false))\n    this._control.clearWayfindingPath()\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Enable a tap handler on assets\n   * @param {Function} cb - The callback that will be run on tap\n   * Accepts two parameters: asset, event\n   * @return {AssetKit} - The current AssetKit\n   */\n  enableAssetTap(cb) {\n    this._enableTapHandler('Tap', cb)\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Enable a double tap handler on assets\n   * @param {Function} cb - The callback that will be run on tap\n   * Accepts two parameters: asset, event\n   * @return {AssetKit} - The current AssetKit\n   */\n  enableAssetDoubleTap(cb) {\n    this._enableTapHandler('DoubleTap', cb)\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Disable the specified tap handlers on assets\n   * @param {Function} cb - The specific function to remove\n   * @return {AssetKit} - The current AssetKit\n   */\n  disableAssetTap(cb) {\n    const callBackList = this._control.stage.events.tapHandlers\n    const cbIndex = callBackList.indexOf(cb)\n    callBackList.splice(cbIndex, 1)\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Disable the specified double tap handler on assets\n   * @param {Function} cb - The specific function to remove\n   * @return {AssetKit} - The current AssetKit\n   */\n  disableAssetDoubleTap(cb) {\n    const callBackList = this._control.stage.events.doubleTapHandlers\n    const cbIndex = callBackList.indexOf(cb)\n    callBackList.splice(cbIndex, 1)\n    return this\n  }\n\n  /**\n   * @access public\n   * @desc - Add a callback for every time an asset's position is updated\n   * @param {Function} cb - The callback that will be run on update of asset\n   * Accepts one parameters: asset\n   * @return {AssetKit} - The current AssetKit\n   */\n  wayfindAssetUpdated(cb) {\n    this._updateAssetCallback = cb\n    return this\n  }\n}\n\n/**\n * A point that describes an x, y coordinate with the mapId that it's on\n * @typedef {Object} JMapPoint\n * @property {number} x - The X coordinate of the point\n * @property {number} y - The y coordinate of the point\n * @property {number} mapId - The ID of the map that the coordinates are on\n */\n\n/**\n * The configuration object for the creation and update of an asset\n * @typedef {Object} assetConfig\n * @property {Map} map - The map the asset will be placed on\n * @property {number[]} position - Coordinates of the asset (as [x, y])\n * @property {number} [id=0] - The ID of the asset\n * @property {string} [name=''] - The name of the asset\n * @property {number} [speed=100] - How quickly the asset should move to new coordinates (pixels\n * per second)\n * @property {number} [orientation=0] - The orientation of the asset's icon\n * @property {string} [type=\"_default\"] - The type of asset\n * @property {boolean} [snapToGrid=false] - Whether the asset should follow the waypoint grid\n * @property {boolean} [snapToWaypoint=false] - Whether the asset should snap to waypoints when\n * repositioning\n *\n * @property {number} [width=20] - The width of the icon\n * @property {number} [height=20] - The height of the icon\n * @property {string} [url] - The URL of the image to be used as the asset's icon\n * @property {boolean} [scaleWithMap=true] - Whether the asset's icon should scale with the map\n * @property {boolean} [rotateWithMap=true] - Whether the asset's icon should rotate with the map\n * @property {number[]} [anchor] - The origin point of the icon, with the two values being\n * percentages of the sprite's dimensions (between 0 and 1)\n * @property {string} [iconColor] - If no url is provided for the icon, the colour of the default\n * icon\n *\n * @property {number} [confidenceMax] - The maximum radius of the confidence circle (in pixels)\n * @property {number} [confidencePercent] - The confidence in the position of the item (between 0\n * and 1). 0 will hide the confidence circle; 1 will display the full circle\n * @property {string} [confidenceColor] - The color of the confidence circle in hexadecimal format\n * @property {number} [confidenceAlpha] - The transparency of the confidence circle (between 0 and\n * 1)\n *\n * @property {string} [pulseColor] - The color of the pulse circle\n * @property {number} [pulseStartAlpha] - The starting opacity of the pulse circle (between 0 and 1)\n * @property {number} [pulseEndAlpha] - The ending opacity of the pulse circle (between 0 and 1)\n * @property {number} [pulseDuration] - The length of time of the pulse animation (in seconds)\n * @property {number} [pulseDelay] - The delay between pulse animation (in seconds)\n * @property {boolean} [pulseVisible] - Whether the pulse should be visible\n */\n\nmodule.exports = AssetKit\n"]}